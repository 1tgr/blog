<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Tim Robinson</title>
  <subtitle type="text"></subtitle>

  <updated>2011-04-05T18:16:55Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://www.partario.com/blog/" />
  <id>http://www.partario.com/blog//feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://www.partario.com/blog//feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[New NPackage binaries]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/05/new-npackage-binaries.html" />
    <id>http://www.partario.com/blog/2010/05/new-npackage-binaries.html</id>
    <updated>2010-05-16T18:57:39Z</updated>
    <published>2010-05-16T18:57:39Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[New NPackage binaries]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/05/new-npackage-binaries.html"><![CDATA[<p id="p1">I've <a href="http://sethgodin.typepad.com/seths_blog/2005/03/dont_shave_that.html">shaved two yaks</a> this weekend:</p>
<ul>
<li>
<p id="p2">Ported the NPackage <code>install</code> command to F#. There shouldn't be any visible change in the application: rather, F# lets me write more succinct code for handling HTTP and package dependencies. (Specifically, I was able to replace a lot of my boilerplace C# code with a <a href="http://msdn.microsoft.com/en-us/library/dd233182.aspx">computation workflow</a> that takes care of deciding which files need to be downloaded again and which ones can be left alone.)</p>
</li>
<li>
<p id="p3">Set up an instance of <a href="http://www.jetbrains.com/teamcity/">TeamCity</a> to take the source code from GitHub and build binaries for me. This isn't a version 1.0 release yet, but you're welcome to download the binaries and help me test them.</p>
</li>
</ul>
<p id="p4"><strong><a href="http://build.partario.com/guestAuth/repository/download/bt2/.lastSuccessful/NPackage.zip">Download the most recent NPackage binaries</a></strong></p>
<p id="p5">PS last week I promised I'd implement package dependencies. I haven't done that yet.</p>
<p id="p6">PPS here's another .NET packaging system to look out for: <a href="http://strangelights.com/blog/archive/2010/05/16/1661.aspx">Sebastien Lambla's OpenWrap</a></p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[This week on NPackage]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/05/this-week-on-npackage.html" />
    <id>http://www.partario.com/blog/2010/05/this-week-on-npackage.html</id>
    <updated>2010-05-09T20:19:43Z</updated>
    <published>2010-05-09T20:19:43Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[This week on NPackage]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/05/this-week-on-npackage.html"><![CDATA[<p id="p1"><a href="http://github.com/timrobinson/NPackage">Browse the NPackage source on GitHub</a></p>
<p id="p2">I implemented the local package database idea that I mentioned last weekend. Now the NPackage client downloads a <a href="http://np.partario.com/packages.js">packages.js</a> file that describes every version of every package; now you don't have to specify full package file URLs with version numbers. I've also switched to <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> syntax for the package files, instead of using my hand-made Yaml-ish parser.</p>
<p id="p3">I want to do at least two more things before putting togther an NPackage version 1.0 release:</p>
<ul>
<li>Packages should be able to depend on other packages. These dependencies should consist of a package name and, optionally, the range of version numbers that are acceptable. NPackage will pick the latest version of each package that satisfies all the version number constraints.</li>
<li>Developers should be able to set up a local package repository that takes prececdence over the web site</li>
</ul>
<p id="p4">Hopefully I'll at least have dependencies working by next weekend.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[First six NPackage packages]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/05/first.html" />
    <id>http://www.partario.com/blog/2010/05/first.html</id>
    <updated>2010-05-03T15:49:34Z</updated>
    <published>2010-05-03T15:49:34Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[First six NPackage packages]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/05/first.html"><![CDATA[<p id="p1"><a href="http://github.com/timrobinson/NPackage">Browse the NPackage source on GitHub</a></p>
<p id="p2">This weekend I've had a couple of productive sessions on NPackage and I'm pretty happy with how it's working out.</p>
<p id="p3">I've set up package files on Amazon S3 for the following libraries:</p>
<ul>
<li><a href="http://np.partario.com/log4net-1.2.10/log4net.np">log4net</a></li>
<li><a href="http://np.partario.com/cecil-0.6/cecil.np">Mono Cecil</a></li>
<li><a href="http://np.partario.com/nhibernate-2.1.2/nhibernate.np">NHibernate</a></li>
<li><a href="http://np.partario.com/nunit-2.5.5.10112/nunit.np">NUnit</a></li>
<li><a href="http://np.partario.com/rhino.mocks-3.6/rhino.mocks.np">Rhino Mocks</a></li>
<li><a href="http://np.partario.com/sharpziplib-0.85.5/sharpziplib.np">SharpZipLib</a></li>
</ul>
<p id="p4">These six packages test a few different scenarios:</p>
<ul>
<li>NUnit and SharpZipLib are needed to build NPackage itself</li>
<li>Rhino Mocks is a good test because the download URL doesn't resemble the name of the file that gets downloaded; I had to write code to parse the HTTP Content-Disposition header to make sense of it</li>
<li>Cecil is an example of a library that's distributed with the rest of Mono, which is supplied as a large .tar.gz archive (the other libraries on the list above are all .zip files)</li>
<li>NHibernate is an example of a library that has its own dependencies, i.e. log4net</li>
</ul>
<p id="p5">Although NPackage is working nicely for its own development, I need to put in more work before the installation process is simple enough. Right now the <a href="http://github.com/timrobinson/NPackage/blob/master/scripts/install">command to install NPackage's own dependencies</a> looks like this:</p>
<div class="pygments_murphy"><pre>NPackage http://np.partario.com/nunit-2.5.5.10112/nunit.np \
         http://np.partario.com/sharpziplib-0.85.5/sharpziplib.np
</pre></div>

<p id="p6">I'd like to simplify it to this:</p>
<div class="pygments_murphy"><pre>np install nunit sharpziplib
</pre></div>

<p id="p7">To do this I'll need to handle dependencies properly. I expect I'll need to drop the approach of putting package descriptions in their own files: the client will need to contain enough intelligence to put together a dependency graph and install the right versions of the right packages. It will be easier to do this if the client can download a central package database list and make its decisions based on the descriptions within there.</p>
<p id="p8">I envisage having local databases that can contain a few local packages and delegate the rest to the central list on the web. I'd also like the client to be self-contained enough to carry on working even if this central package server falls over: the client should cache the most recent version of the list and work from there.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[NPackage news]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/04/npackage-news.html" />
    <id>http://www.partario.com/blog/2010/04/npackage-news.html</id>
    <updated>2010-04-27T13:00:00Z</updated>
    <published>2010-04-27T13:00:00Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[NPackage news]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/04/npackage-news.html"><![CDATA[<p id="p1">I've had some time over the last couple of evenings to do some coding, so I've made a start on my package manager. So far I'm calling it <strong>NPackage</strong>.</p>
<p id="p2">I defined a Yaml-format package file, containing the package name, description, version number; the name and email address of the maintainer; and an optional field for the URL of the download site. The package file then contains a list of libraries (i.e. .NET assembles) contributed by the package, with download URLs specified relative to the download site. </p>
<p id="p3">The idea behind making the download URL optional is that these package files can point to an existing download site for established libraries like NUnit. If the download URL is omitted then the NPackage client will look for binaries on the NPackage server, in the same location as the package file itself. A lot of libraries are going to be distributed in .zip files, so I was planning on having the NPackage client download these .zip files and unpack them into the layout dictated by the package file.</p>
<p id="p4">I'm using NPackage to develop NPackage, which means I had to hack together the parsing and download code myself without any unit testing framework or parsing library. Now that I've done that, I've hand-crafted a package file for NUnit (<code>nunit.np</code>) that'll let me start writing unit tests.</p>
<p id="p5">There are a few areas I'm not sure about:</p>
<ul>
<li>I've started writing it in C#, but I'm tempted to switch to F#, at least for the core functionality. I'm expecting to need some strong dependency graph logic (for dependencies between packages and between files within a package), which will be easier to code in F#. However I'd like to be able to be able to build the sources on Mono, and I'm not aware of a standard way of invoking the F# compiler from a Mono build process.</li>
<li>I'm only dealing with binary distribution for now (and <a href="http://en.wikipedia.org/wiki/XCOPY_deployment">xcopy deployment</a> at that). Building .NET libraries from source in a standard way could be tricky.</li>
<li>I've picked a <a href="http://en.wikipedia.org/wiki/Yaml">Yaml</a>-based file format over XML because I expect these package files to be created by hand. As a result, it's going to be harder to generate or parse these files as part of an automated build system.</li>
</ul>
<p id="p6">Here's the notes I made before I got started:</p>
<blockquote>
<ol>
<li>Find the package</li>
<li>Package files like in cabal</li>
<li>A couple of standard locations: Hackage-like web server, internal source control repository</li>
<li>Package identified by: name and version</li>
<li>Deal with variants (like: 2.0 vs 3.5 vs 4.0; 32-bit vs 64-bit) by having separate packages released at the same time</li>
<li>Install dependencies</li>
<li>Package files declare their own dependencies, cabal style</li>
<li>Recursively fetch and install dependencies</li>
<li>Download the code</li>
<li>Package file specifies location of source code (default is src/ directory relative to package file)</li>
<li>Packages can release binaries only, e.g. NUnit, log4net etc. get downloaded from their normal locations</li>
<li>Support fetching from source control as well as HTTP? - may make sense for internal deployments, what about mixing matching SCC systems?</li>
<li>Build the code</li>
<li>Skip this if the package just has binaries</li>
<li>Reference the binaries</li>
<li>Update VS solution and project files</li>
</ol>
</blockquote>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[.NET package manager feedback]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/04/net-package-manager-feedback.html" />
    <id>http://www.partario.com/blog/2010/04/net-package-manager-feedback.html</id>
    <updated>2010-04-19T18:19:54Z</updated>
    <published>2010-04-19T18:19:54Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[.NET package manager feedback]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/04/net-package-manager-feedback.html"><![CDATA[<p id="p1">I don't seem to be the first one to be having problems keeping track of his .NET binaries:</p>
<ul>
<li><a href="http://twitter.com/TheColonial/status/12416813543">OJ offered to build one</a> :)</li>
<li>John Mandia poined me towards several Java-based tools: <a href="http://www.jfrog.org/products.php">Artifactory</a>, <a href="http://www.anthillpro.com/html/default.html">Antill Pro</a> and <a href="http://nexus.sonatype.org/">Nexus</a>. Of these, Artifactory and Nexus are open source. Of course, Apache <a href="http://maven.apache.org/">Maven</a> is a fairly well-known Java packaging tool.</li>
<li><a href="http://twitter.com/jimmcslim/status/12417586016">James Webster showed me</a> the <a href="http://vsdm.codeplex.com/Wikipage">Visual Studio Dependencies Manager</a>, an addin for Visual Studio 2003.</li>
</ul>
<p id="p2">Finally, <a href="http://www.partario.com/blog/2010/04/can-i-have-a-net-package-manager.html#comment-39">Terry Spitz</a> had some fairly enthusiastic feedback:</p>
<blockquote>
<p id="p3">hell yes! we've got various vbscripts to do this. shouldn't it be 'easy' in say MSI (if too heavyweight), or powershell. additional points if it can handle multi-level caching, i.e. cross-region or internet code is cached on a team share as well as locally.</p>
</blockquote>
<p id="p4">Windows Installer occurred to me when I started thinking about this. However, I think such a tool should be limited to deploying assemblies to a particular project's source tree -- deploying them via MSIs suggests putting them into a central location on each machine, and I predict that individual projects will start interfering with each other this way, particularly on a build server. On the other hand, Windows Installer does have the concept of <a href="http://en.wikipedia.org/wiki/Merge_module">merge modules</a>: mini MSIs for software components that get merged into the final application installer.</p>
<p id="p5">Terry's multi-level caching idea is nice. There should definitely be local team and Internet repositories. Additionally, geographically distributed teams probably want local caches to keep overhead to a minimum. And I noticed that my Amazon-based web server cleverly goes to a special Ubuntu package repository hosted on S3, which keeps things quick and hopefully reduces my bandwidth costs.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Can I have a .NET package manager?]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/04/can-i-have-a-net-package-manager.html" />
    <id>http://www.partario.com/blog/2010/04/can-i-have-a-net-package-manager.html</id>
    <updated>2010-04-18T20:28:29Z</updated>
    <published>2010-04-18T20:28:29Z</published>
    <category scheme="http://www.partario.com/blog/" term="NPackage" />
    <summary type="html"><![CDATA[Can I have a .NET package manager?]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/04/can-i-have-a-net-package-manager.html"><![CDATA[<p id="p1">Insipired by source code packaging systems like <a href="http://www.haskell.org/cabal/">Haskell Cabal</a>, I'd like a standard tool for publishing shared code. I've seen teams take a variety of sub-optimal approaches, including: building everything from source each time; building binaries once then referencing them from a network share; and building binaries then checking them into source control.</p>
<p id="p2">As a developer, what I'd like to be able to do is to declare the external libraries that my code depends on. I'd like it to work the same way for third-party code (say, NUnit and log4net) as for my own code (say, a library that gets re-used across several apps on the same team). There should be a standard format for publishing libraries, but there should be minimal effort involved in pulling one of these libraries into my code.</p>
<p id="p3">What I propose is:</p>
<ul>
<li><strong>One or more central package sites.</strong> One could be a public web site that maintains a list of open-source libraries; teams could host their own for internal libraries. These internal sites could just be directories in the file system or in source control. Package sites just contain enough information to find the right binaries or source code -- the binaries and sources themselves don't have to live at the same site.</li>
<li>A <strong>command line app that updates packages to the current version,</strong> either by downloading binaries or by downloading and building source code. This would run on individual developers' PCs and on a continuous integration server.</li>
<li>A <strong>tool for keeping Visual Studio project references up to date.</strong> I spend far too much time in the Project References dialog -- or editing .csproj files by hand -- to fix broken reference paths and libraries accidentally referenced from a developer's GAC.</li>
</ul>
<p id="p4">I don't know of anything that solves the problem as cleanly as in other languages. Am I missing something?</p>]]></content>
  </entry>
</feed>
