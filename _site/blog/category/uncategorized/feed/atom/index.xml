<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Tim Robinson</title>
  <subtitle type="text"></subtitle>

  <updated>2011-04-05T18:16:55Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://www.partario.com/blog/" />
  <id>http://www.partario.com/blog//feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://www.partario.com/blog//feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Movable Type on EC2]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/04/movable-type-on-ec2.html" />
    <id>http://www.partario.com/blog/2010/04/movable-type-on-ec2.html</id>
    <updated>2010-04-18T20:00:00Z</updated>
    <published>2010-04-18T20:00:00Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Movable Type on EC2]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/04/movable-type-on-ec2.html"><![CDATA[<p id="p1">I'm a big fan of virtual servers and I've always run this web site from one. Until recently I had it on a <a href="http://www.partario.com/blog/2009/04/first-post.html">VMware instance on my home PC</a>, although <a href="http://www.partario.com/blog/2010/03/a-render-farm-in-haskell.html">my recent experience with Amazon EC2</a> and a couple of large traffic spikes prompted me to move it.</p>
<p id="p2">In the end the process turned out to be pretty easy:</p>
<ol>
<li>Back up to Amazon S3 using <a href="http://duplicity.nongnu.org/">duplicity</a>:</li>
<li>MySQL dump: <code>mysqldump --all-databases</code></li>
<li>/etc/apache2</li>
<li>/var/www</li>
<li>Start an EC2 small instance running AMI Ubuntu 9.04 (ami-ccf615a5)</li>
<li>Restore from Amazon S3</li>
<li><code>apt-get -y install apache2 duplicity libapache2-mod-perl2 libdbd-mysql-perl libdbi-perl mysql-server perlmagick python-boto</code></li>
<li>Restore MySQL dump, /etc/apache2 and /var/www using duplicity</li>
<li>Run MySQL script against the local instance</li>
<li>Start Apache. Check whether the static HTML pages and Movable Type's admin interface work.</li>
<li>Assign an Amazon elastic IP address to the EC2 instance. This gives me a static IP address that I can refer to from DNS.</li>
<li>Remap the DNS alias (an A record and a CNAME record) via my ISP's web site</li>
<li>Done!</li>
</ol>
<p id="p3">I'm happy with the changes so far:</p>
<ul>
<li>Performance has been fine: although publishing the site now takes 30 seconds not 15, I'm getting much better response times and bandwidth</li>
<li>I'm paying to run an EC2 instance full time whereas before I was just paying for home power bills</li>
<li>I'm not going to get shot by my ISP next time one of my posts appears on Reddit</li>
</ul>
<p id="p4">The fact that I was taking daily backups made the move risk-free. It took a couple of attempts to get a working site on the EC2 server, but I was able to start a fresh instance and restore from backup each time. I also know that, if the site does fall over in future, restoring from backup will take a few minutes and I'll lose one day of data at most.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Cherry Blossom in Jubilee Place]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/04/cherry-blossom-in-jubilee-place.html" />
    <id>http://www.partario.com/blog/2010/04/cherry-blossom-in-jubilee-place.html</id>
    <updated>2010-04-12T09:07:35Z</updated>
    <published>2010-04-12T09:07:35Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Cherry Blossom in Jubilee Place]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/04/cherry-blossom-in-jubilee-place.html"><![CDATA[<p id="p1"><a href="http://www.flickr.com/photos/tim-robinson/4511725083/" title="photo sharing"><img src="http://farm3.static.flickr.com/2168/4511725083_61ec2dc0c2_d.jpg" alt="" class="mt-image-none"/></a>
<br/>
<span style="font-size: 0.9em; margin-top: 0px;">
<a href="http://www.flickr.com/photos/tim-robinson/4511725083/">Jubilee Place Cherry Blossom - 2</a>
<br/>
Originally uploaded by <a href="http://www.flickr.com/people/tim-robinson/">Tim Robinson</a>
</span>
<p id="p2">Summer has almost arrived in London -- I took this at the weekend in one of the parks close to where I work.</p></p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[A render farm in Haskell]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2010/03/a-render-farm-in-haskell.html" />
    <id>http://www.partario.com/blog/2010/03/a-render-farm-in-haskell.html</id>
    <updated>2010-03-07T19:40:00Z</updated>
    <published>2010-03-07T19:40:00Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[A render farm in Haskell]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2010/03/a-render-farm-in-haskell.html"><![CDATA[<p id="p1"><a href="http://github.com/timrobinson/smallpt-haskell">Browse the full source of the ray tracer on GitHub</a></p>
<p id="p2">A few weeks back I came across the <a href="http://kevinbeason.com/smallpt/">smallpt ray tracer</a> by Kevin Beason. smallpt is a global illumination renderer written in 99 lines of C++. Since it uses a <a href="http://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo</a> technique to randomly cast rays and average the results, the longer you can leave it running, the better the image will look. Kevin's code uses OpenMP to split calculations across more than one CPU core.</p>
<p id="p3"><a href="http://github.com/timrobinson/smallpt-haskell/raw/master/1024-768-4000spp.png"><img alt="Sample smallpt image" src="http://www.partario.com/blog/2010/03/07/1024-768-4000spp.png" width="540" height="405" class="mt-image-none" style=""/></a></p>
<p id="p4">Since ray tracing is the sort of mathsy task that Haskell excels at, I wanted to see how what a Haskell port of Kevin's code looked like. That code itself isn't the subject of this article, because what I wanted to write about instead are the techniques you can use to distribute Haskell code across multiple cores. These techniques range from <code>parMap</code> (which is almost transparent to the program, but provides little control over where the code runs) to brute-force distribution of work across several machines.</p>
<h3>parMap</h3>
<p id="p5">One of the things I love about Haskell is that its pure functional nature makes it straightforward to parallelise code within a single machine. You can normally take any code implemented in terms of <code>map</code> and parallelise it with <code>parMap</code>, from the <a href="http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html">Control.Parallel.Strategies</a> module. <code>parMap</code> will use lightweight threads provided by the runtime to apply a function to each element in a list in parallel.</p>
<p id="p6">The <code>parMap</code> function accepts an argument that controls the evaluation strategy. Most of the examples I've seen use <code>parMap rwhnf</code> ("weak head normal form"), which only evaluates the outside of a data structure; the insides of your data are evaluated lazily, and this doesn't necessarily happen on one of the parallel lightweight threads as intended.</p>
<p id="p7">To evaluate anything more complicated than a list of simple values in you'll probably need to use <code>parMap rdeepseq</code>, which recurses inside your data on the lightweight thread so that it's fully evaluated by the time <code>parMap</code> finishes. <code>rdeepseq</code> is defined in terms of the <a href="http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html">Control.DeepSeq</a> module, and if you've defined your own types, you'll find you need to implement <code>NFData</code>.</p>
<p id="p8">A final note on <code>parMap</code>: don't forget to compile with the <code>-threaded</code> flag, then run your program with <code>+RTS -Nx</code>, where _x_ is the number of CPU cores you want to distribute across.</p>
<h3>forkIO</h3>
<p id="p9">Haskell supports good old-fashioned manual concurrency with functions in the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html">Control.Concurrent</a> module. This works broadly the same as in other languages:</p>
<ul>
<li>Use <code>forkIO</code> to start an IO computation in parallel with the current thread</li>
<li>Threads can communicate through objects called MVars: create a new one using <code>newEmptyMVar</code> or <code>newMVar</code></li>
<li>MVars can be empty, or they can hold at most one value:</li>
<li>Read a value from an MVar using <code>takeMVar</code>. This will block if the MVar is currently empty.</li>
<li>Write a value to an MVar using <code>putMVar</code>. This will block if the MVar is currently full. Calling <code>putMVar</code> wakes up one of the threads that's blocked inside <code>takeMVar</code>.</li>
</ul>
<p id="p10"><code>forkIO</code> starts a computation in parallel and lets you essentially forget about it; mvars are an effective way of encapsulating mutable state shared between more than one thread. What I like about this is that there's no error-prone manual locking like you'd find in, say, Java or .NET. Although <code>forkIO</code> and mvars give you full control over thread scheduling, they're not drop-in replacements for sequential calculations in the same way as <code>parMap</code>.</p>
<h3>Brute force</h3>
<p id="p11">The previous two techniques rely on the multi-threading capabilities of the Haskell runtime. They know nothing of what's happening outside of a single Haskell process, which limits them to the number of cores present in the machine. To go beyond that, separate instances of your program will need to communicate with each other over a network.</p>
<p id="p12">In my Haskell port of smallpt, I used this technique to run as many instances of the program as needed: one process per core on the local machine, and one process on each of a range of instances running on Amazon EC2. The communication protocol is as simple as possible: plain text over pipes. I used <code>ssh</code> to communicate with the EC2 instances, so from the outside there's no difference between a local instance and one running on the cloud.</p>
<p id="p13"><a href="http://github.com/timrobinson/smallpt-haskell/blob/master/Tim/Smallpt/Distribution.hs">The algorithm</a> goes as follows:</p>
<ol>
<li>Establish the work you need to do. In this case, a work item is one line in the final rendered image.</li>
<li>Split the work into tasks you can give to the worker processes. For simplicity, I'm splitting the work equally to give one task to each worker.</li>
<li>Launch the workers and provide them with the task inputs. Since workers accept plain text, I take a <code>Work</code> object and <code>hPrint</code> it to a pipe.</li>
<li>When each worker finishes, collect its output. Outputs will come back in an unpredictable order.</li>
<li>When all the workers are done, sort all of the outputs into the same order as the inputs</li>
</ol>
<p id="p14">The coordinator is the program you launch from the command line, and it deals with things like command-line parsing, executing the distribution algorithm above, and writing a .png format image at the end. The worker processes are themselves instances of the <code>smallpt</code> executable, launched with the <code>-r</code> flag. In effect what each <code>smallpt -r</code> does is:</p>
<pre><code>-- Render one line of the scene and return it as a list of pixels
line :: (Floating a, Ord a, Random a) =&gt; Context a -&gt; Int -&gt; [Vec a]

runWorker = interact (show . map line . read)
</code></pre>
<p id="p15">One potential flaw in this is that, because you're communicating over plain text, the Haskell type system won't trap any errors: there isn't necessarily any link between the types in the coordinator and the types in the worker. The interface to the distribution code consists of a <code>Coordinator a b</code> record, where <code>a</code> is the type for inputs to the workers, and <code>b</code> is the type that the workers produce as output:</p>
<pre><code>data (Show a, Read b) =&gt; Coordinator a b = 
    Coordinator { submitWork :: [String] -&gt; [a] -&gt; IO [b],
                  runWorker :: IO () }

coordinator :: (Read a, Show a, Read b, Show b) =&gt; (a -&gt; b) -&gt; Coordinator a b
coordinator worker = 
    Coordinator { submitWork = submitWork',
                  runWorker = interact (show . map worker . read) }
</code></pre>
<p id="p16">Most of the multi-threading code lives inside the <code>submitWork'</code> function which implements the algorithm above:</p>
<ol>
<li>Given a list of worker commands lines (<code>[String]</code>) and the work itself (<code>[a]</code>), produce a list of tuples of workers and tasks</li>
<li>Using <code>forkIO</code>, fork one thread per worker. Inside each of these threads:</li>
<li>Start the worker process itself (via <code>createProcess shell</code>)</li>
<li>Write an <code>[a]</code> to its standard input</li>
<li>Read a <code>[b]</code> from its standard output</li>
<li>Put the <code>[b]</code> into an mvar shared between all worker threads</li>
<li>Back in the coordinator thread, call <code>takeMVar</code> once for each worker. This produces a list of results as a <code>[[b]]</code>.</li>
<li>Once all the workers have finished, collapse the results into a <code>[b]</code>, making sure the output list comes back in the same order as the original inputs. If any of the workers encountered an error, use <code>ioError</code> to fail the whole operation.</li>
</ol>
<p id="p17">This approach works remarkably well for this simple ray tracer demo. But it has some serious flaws that you'd want to avoid in a production system:</p>
<ul>
<li>Any failed worker process invalidates the whole set of results. Even in the absence of software bugs, machines can fail any time (consider how often disks fail when you've got 4,000 of them). The coordinator should recognise transient errors and retry those tasks; it might choose to take workers out of rotation if they fail repeatedly.</li>
<li>All machines are assumed to be equally powerful. This is rarely the case: for instance, workers running on my Mac here finish far sooner than ones on my small Amazon instances.</li>
<li>All work is assumed to take the same length of time to complete. Even in this simple ray tracer, plain diffuse surfaces are much easier to calculate than reflective (shiny) ones or refractive (transparent) ones.</li>
<li>Tasks are allocated up front. If a worker finishes early -- maybe because it's running on a Mac Pro, or because it generated a line of empty space -- it can't have any more work allocated to it.</li>
<li>Workers can't spawn other workers. In my code the worker function isn't declared in the IO monad, so it can't interact with anything. Even if it could, it would need to know about all of the other workers so that it could pick an idle core to do work on.</li>
</ul>
<p id="p18">Next time I'll talk about some of the code in the ray tracer itself, as well as some approaches you'd use in practice to correct these flaws in the demo.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[An improved spelling corrector in Haskell]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/11/an-improved-spelling-corrector-in-haskell.html" />
    <id>http://www.partario.com/blog/2009/11/an-improved-spelling-corrector-in-haskell.html</id>
    <updated>2009-11-01T11:09:54Z</updated>
    <published>2009-11-01T11:09:54Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[An improved spelling corrector in Haskell]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/11/an-improved-spelling-corrector-in-haskell.html"><![CDATA[<p id="p1"><a href="http://www.partario.com/blog/2009/10/a-spelling-corrector-in-haskell.html">My previous post</a> came up on the <a href="http://www.reddit.com/r/haskell/comments/9zowr/a_spelling_corrector_in_haskell/">Haskell Reddit</a> yesterday, and I got some great suggestions for improvements to the program, which <a href="http://github.com/timrobinson/spell-correct/blob/master/Correct.hs">I've checked into GitHub</a>.</p>
<ul>
<li>
<p id="p2"><code>Map.fromListWith</code> replaces <code>List.foldl'</code> and <code>Map.insertWith'</code>. <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3AfromListWith"><code>fromListWith</code></a> appears to be specifically designed for aggregating values that share a common key (in .NET terminology it's the <a href="http://msdn.microsoft.com/en-us/library/bb534501.aspx"><code>GroupBy</code></a> function).</p>
</li>
<li>
<p id="p3">I'll commonly use a construct like <code>readFile "big.txt" &gt;&gt;= return . train . lowerWords</code>, to bind a monad value <code>readFile "big.txt"</code> to a function <code>(train . lowerWords)</code>, then produce a new monad value with <code>return</code>. A shorter way to write this is <code>fmap (train . lowerWords) (readFile "big.txt")</code>, or, with an import from Control.Applicative, <code>(train . lowerWords &lt;$&gt; readFile "big.txt")</code>.</p>
</li>
<li>
<p id="p4">You can replace the lambda syntax <code>(\w -&gt; Map.lookup w nwords)</code> with an operator section, <code>('Map.lookup' nwords)</code>. You might see this more commonly as <code>(+1)</code> in place of <code>(\x -&gt; x + 1)</code>; it's the same thing. <strong class="alt">Edit:</strong> the challenging Markdown syntax means that you'll have to imagine the single quotes around <code>Map.lookup</code> replaced with backticks, `.</p>
</li>
</ul>
<p id="p5">I should have realised this at the time, but it didn't occur to me that <a href="http://www.haskell.org/onlinereport/exps.html#list-comprehensions">you can use full pattern-matching syntax in the right-hand side of a Haskell list comprehension</a>. If the match fails on some element then that element is filtered out. We can use this to improve on the Python version of the <code>edits1</code> function: whereas the Python version combines its <code>b[0]</code> subscripts with an <code>if b</code> check, the Haskell version can use pattern matching to do both. We can also use the <code>inits</code> and <code>tails</code> functions to build substrings instead of brute-force applications of <code>take</code> and <code>drop</code>.</p>
<div class="pygments_murphy"><pre># Python
def edits1(word):
   s = [(word[:i], word[i:]) for i in range(len(word) + 1)]
   deletes    = [a + b[1:] for a, b in s if b]
   transposes = [a + b[1] + b[0] + b[2:] for a, b in s if len(b)&gt;1]
   replaces   = [a + c + b[1:] for a, b in s for c in alphabet if b]
   inserts    = [a + c + b     for a, b in s for c in alphabet]
   return set(deletes + transposes + replaces + inserts)

&gt; -- Haskell
&gt; edits1 word = let s = zip (inits word) (tails word)
&gt;                   deletes    = [ a ++ y     | (a, _:y  ) &lt;- s ]
&gt;                   transposes = [ a ++ y:x:z | (a, x:y:z) &lt;- s ]
&gt;                   replaces   = [ a ++ c:y   | (a, _:y  ) &lt;- s, c &lt;- alphabet ]
&gt;                   inserts    = [ a ++ c:x   | (a, x    ) &lt;- s, c &lt;- alphabet ]
&gt;                in Set.fromList $ concat [ deletes, transposes, replaces, inserts ]
</pre></div>

<p id="p6">The <code>edits1</code> function is the densest one in both the Python and Haskell versions. It's the one where the intent of the code was least clear to me when I originally saw it, probably because of the extra clutter in the list comprehensions. In the latest Haskell revision it's more obvious what's going on.</p>
<p id="p7">I've consistently used the names <code>x</code>, <code>y</code> and <code>z</code> for the first three parts of the word's suffix. Because they consistently stand for the same thing, any inconsistencies jump out at you when you read the code:</p>
<ul>
<li><code>a ++ y</code> stands out because <code>x</code> is missing; it's been <em>deleted</em>. (<code>x</code> isn't even mentioned in the pattern match.)</li>
<li><code>a ++ y:x:z</code> stands out because <code>x</code> and <code>y</code> are the wrong way round; we're <em>transposing</em> them</li>
<li><code>a ++ c:y</code> stands out because we've got <code>c</code> instead of <code>x</code>; <code>x</code> has been <em>replaced</em>. (Again, <code>x</code> has dropped out of the pattern match.)</li>
<li><code>a ++ c:x</code> has <code>c</code> in front of <code>x</code>; it's been <em>inserted</em></li>
</ul>
<p id="p8">After I'd written the first Haskell version I was skeptical. The Python version uses some typical Python idioms, like <code>if b</code> for checking for empty strings, using the same syntax for accessing lists and sets, and overloading the <code>or</code> operator to look for the first non-empty set, and Haskell doesn't have these same shortcuts. However the latest set of revisions makes the the core algorithm in the Haskell version more readable than the Python equivalent.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[A spelling corrector in Haskell]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/10/a-spelling-corrector-in-haskell.html" />
    <id>http://www.partario.com/blog/2009/10/a-spelling-corrector-in-haskell.html</id>
    <updated>2009-10-31T15:07:09Z</updated>
    <published>2009-10-31T15:07:09Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[A spelling corrector in Haskell]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/10/a-spelling-corrector-in-haskell.html"><![CDATA[<p id="p1"><strong class="alt">Update:</strong> Thanks to the commenters on this blog and on Reddit, I've got <a href="http://www.partario.com/blog/2009/11/an-improved-spelling-corrector-in-haskell.html">a much improved and more readable Haskell port</a> of the spelling corrector.</p>
<p id="p2">On Wednesday I attended the <a href="http://stackoverflow.carsonified.com/events/london/">StackOverflow DevDay</a> in London, which was a day of excellent talks by engaging speakers. Michael Sparks gave a talk on Python, where he built up <a href="http://www.norvig.com/spell-correct.html">Peter Norvig's spelling corrector</a> line by line as we watched. I was impressed by how easy it was to understand the source code, and the style struck me as being particularly functional. So, I was compelled to translate the Python source into Haskell.</p>
<p id="p3">This post is also a Literate Haskell program, meaning that you should be able to copy the text from the page, paste it into a <code>.lhs</code> file, and compile it. Snippets starting with <code>&gt;</code> are Haskell; in between is Peter's original program, and my commentary on the differences.</p>
<div class="pygments_murphy"><pre># Python code looks like this:
import re, collections

&gt; -- Haskell code looks like this:
&gt; module Tim.Spell.Correct where
&gt;
&gt; import Char
&gt; import qualified Data.List as List
&gt; import qualified Data.Map as Map
&gt; import qualified Data.Set as Set
&gt; import Data.Ord
&gt; import List
</pre></div>

<p id="p4">Every language needs some imports. The Python program only has two; we're using a scattering of functions outside of the prelude (Haskell's standard library), so we need to import a bit more:</p>
<ul>
<li><code>Char</code> gives us <code>toLower</code> and <code>isAlpha</code></li>
<li><code>Data.List</code> gives us <code>foldl'</code></li>
<li><code>Data.Map</code> gives us the <code>Map</code> type</li>
<li><code>Data.Set</code> gives us the <code>Set</code> type</li>
<li><code>Data.Ord</code> gives us the <code>comparing</code> function</li>
<li><code>List</code> gives us <code>maximumBy</code></li>
</ul>
<div class="pygments_murphy"><pre>def words(text): return re.findall('[a-z]+', text.lower())

&gt; lowerWords = filter (not . null) . map (map toLower . filter isAlpha) . words
</pre></div>

<p id="p5">The Haskell prelude already has a function called words, which splits a string by spaces. <code>filter isAlpha</code> and <code>filter (not . null)</code> approximate the Python regular expression:</p>
<ul>
<li><code>filter isAlpha</code> drops all characters outside of a-z</li>
<li><code>filter (not . null)</code> excludes any empty strings (such as sequences of numbers or punctuation in the original text)</li>
</ul>
<div class="pygments_murphy"><pre>def train(features):
    model = collections.defaultdict(lambda: 1)
    for f in features:
        model[f] += 1
    return model

&gt; train = List.foldl' (\dict word -&gt; Map.insertWith' (+) word (1::Int) dict) Map.empty 
</pre></div>

<p id="p6">Haskell doesn't need an explicit loop here: we use <code>foldl'</code> to iterate over the list of words and add each one to a map. The <code>Map.insertWith'</code> function either inserts a value (if missing), or extracts the existing value, applies it to a function, and inserts the result back in the map.</p>
<div class="pygments_murphy"><pre>NWORDS = train(words(file('big.txt').read()))

&gt; readNWORDS = readFile "big.txt" &gt;&gt;= return . train . lowerWords
</pre></div>

<p id="p7">A big difference in the Haskell version is that file I/O is encapsulated in an IO monad. So whereas Python's <code>NWORDS</code> variable is an actual dictionary, <code>readNWORDS</code> is a I/O value that, when executed, reads and parses a file and yields a dictionary.</p>
<div class="pygments_murphy"><pre>alphabet = 'abcdefghijklmnopqrstuvwxyz'

&gt; alphabet = [ 'a' .. 'z' ]
</pre></div>

<p id="p8">I put a cheeky shortcut in the Haskell version. (It makes no difference to the line count.)</p>
<div class="pygments_murphy"><pre>def edits1(word):
   s = [(word[:i], word[i:]) for i in range(len(word) + 1)]
   deletes    = [a + b[1:] for a, b in s if b]
   transposes = [a + b[1] + b[0] + b[2:] for a, b in s if len(b)&gt;1]
   replaces   = [a + c + b[1:] for a, b in s for c in alphabet if b]
   inserts    = [a + c + b     for a, b in s for c in alphabet]
   return set(deletes + transposes + replaces + inserts)

&gt; edits1 word =
&gt;     let s = [ (take i word, drop i word) | i &lt;- [ 0 .. length word ] ]
&gt;         deletes    = [ a ++ tail b | (a, b) &lt;- s, not $ null b ]
&gt;         transposes = [ a ++ b!!1 : b!!0 : drop 2 b | (a, b) &lt;- s, not $ null b, not $ null $ tail b ]
&gt;         replaces   = [ a ++ c : tail b | (a, b) &lt;- s, c &lt;- alphabet, not $ null b ]
&gt;         inserts    = [ a ++ c : b | (a, b) &lt;- s, c &lt;- alphabet ]
&gt;     in Set.fromList (deletes ++ transposes ++ replaces ++ inserts)
</pre></div>

<p id="p9">The Haskell and Python versions of this function are fairly close. The main differences:</p>
<ul>
<li>Haskell uses the <code>let</code> ... <code>in</code> keywords to declare values</li>
<li>List comprehension syntax is very similar, if you replace Python's <code>for</code> and <code>in</code> with Haskell's <code>|</code> and <code>&lt;-</code>. (Recurring theme: Haskell prefers symbols to keywords.)</li>
<li><code>[ start .. end ]</code> is Haskell's built-in range syntax. It's lazy, and generates elements only on demand, which means it's fine to construct an infinite list like this: <code>[ 1 .. ]</code></li>
<li>Python has neat string slicing syntax:</li>
<li><code>[:i]</code> is replaced with <code>take i</code>, to take the first _i_ characters</li>
<li><code>[i:]</code> is replaced with <code>drop i</code>, to take all but the first _i_ characters</li>
<li>Subscripts can be replaced with the <code>!!</code> operators, which does the same thing, but with O(_N_) complexity. Remember Haskell's strings are lists of characters, not arrays (although see <code>Data.ByteString</code>).</li>
<li>Python's <code>if</code> keyword maps to different things depending on the context. Here it's used to ask 'is the string empty?', and we replace it with the <code>not</code> and <code>null</code> functions.</li>
<li><code>++</code> and <code>:</code> stand in for Python's <code>+</code> operator, depending on whether we're concatenating two lists (<code>a ++ b</code>) or pushing a single element onto the start of a list (<code>head : tail</code>)</li>
</ul>
<p id="p10">I'm not totally convinced about the performance of the Haskell version, since <code>take</code> and <code>drop</code> are O(<em>N_) and not O(1). However, _N</em> is small here, being the length of a word. If it's a problem we could use <code>ByteString</code> instead for O(1) complexity at the price of having to copy strings.</p>
<div class="pygments_murphy"><pre>def known_edits2(word):
    return set(e2 for e1 in edits1(word) for e2 in edits1(e1) if e2 in NWORDS)

&gt; known_edits2 knownWords = Set.unions . Set.elems . Set.map (Set.intersection knownWords . edits1) . edits1
</pre></div>

<p id="p11">Here I replaced the Python list comprehensions with Haskell's built-in set functions. We can't iterate directly over a set in Haskell, so if we used a list comprehension here, we'd to use <code>elems</code> to produce a list from the set and <code>fromList</code> to turn the result into a set again. Here I feel that the Python version demonstrates the intent more clearly, which is to produce a set of edits from <code>edit1</code>, then run those through <code>edit1</code> again, and keep only the edits that turn out to be real words.</p>
<p id="p12">Read from right to left, what the Haskell version does is:</p>
<ul>
<li>Produces a set of edits to a word using <code>edit1</code></li>
<li>For each edit in the set, produce another set of edits using <code>edit1</code>, and keep only those edits-of-edits that can be found in <code>knownWords</code>. We now have a set of sets.</li>
<li>Turn a set of sets into a list of sets, using <code>elems</code></li>
<li>Collapse that list of sets into a single set of words using <code>unions</code></li>
</ul>
<div class="pygments_murphy"><pre>def known(words): return set(w for w in words if w in NWORDS)

&gt; -- no Haskell equivalent
</pre></div>

<p id="p13">The <code>known</code> function actually disappears in the Haskell version. Because it takes a set of known words instead of a map of word frequencies, it turns into a direct call to <code>intersection</code> lower down.</p>
<div class="pygments_murphy"><pre>def correct(word):
    candidates = known([word]) or known(edits1(word)) or known_edits2(word) or [word]
    return max(candidates, key=NWORDS.get)

&gt; correct nwords word = 
&gt;     let knownWords = Map.keysSet nwords
&gt;         candidates = Set.elems
&gt;                    $ head
&gt;                    $ filter (not . Set.null)
&gt;                    $ [ Set.intersection knownWords $ Set.singleton word,
&gt;                        Set.intersection knownWords $ edits1 word,
&gt;                        known_edits2 knownWords word,
&gt;                        Set.singleton word ]
&gt;       in maximumBy (comparing (\w -&gt; w `Map.lookup` nwords)) candidates
</pre></div>

<p id="p14">Python has a magic short-circuiting <code>or</code> operator, which we have to fake by putting together a list of sets and finding the first non-empty one. Because Haskell is lazy this does in fact short-circuit: for instance, we never make a call to <code>known_edits2</code> if we can already find <code>word</code> in <code>knownWords</code>.</p>
<p id="p15">I'm not a fan of <code>maximumBy</code> in Haskell, which makes you compare two items yourself; I prefer the Python version, which is similar to .NET's <code>OrderBy</code> function. Here, though, the <code>comparing</code> function in <code>Data.Ord</code> makes the code a little less verbose.</p>
<p id="p16">Finally, here's a little command-line demo that corrects words the user types in. It's only at this point that the Haskell version touches the text file that the Python program encapsulates in the <code>NWORDS</code> variable; the Haskell version passes the dictionary through each function that needs it. I could have done a direct translation of the Python, but this would have meant writing most of the program as imperative IO monad code, which wasn't really the point of the Haskell translation.</p>
<div class="pygments_murphy"><pre>&gt; prompt nwords = do
&gt;     eof &lt;- isEOF
&gt;     if eof
&gt;       then return ()
&gt;       else do
&gt;           getLine &gt;&gt;= putStrLn . correct nwords
&gt;           prompt nwords
&gt; 
&gt; main = readNWORDS &gt;&gt;= prompt
</pre></div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Obscure exception handling facts]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/07/obscure-exception-handling-facts.html" />
    <id>http://www.partario.com/blog/2009/07/obscure-exception-handling-facts.html</id>
    <updated>2009-07-28T20:22:43Z</updated>
    <published>2009-07-28T20:22:43Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Obscure exception handling facts]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/07/obscure-exception-handling-facts.html"><![CDATA[<p id="p1"><span class="alt">(The second in what seems to be a day of obscure .NET facts)</span></p>
<p id="p2">While looking at some C++/CLI code in Reflector today at work, we encountered the <code>try ... fault</code> construct.</p>
<h3>What's a <code>fault</code> block?</h3>
<p id="p3">It's like a <code>finally</code> block, but it's only entered in the event of an exception.</p>
<h3>So it's like a <code>catch</code> block, then?</h3>
<p id="p4">Not exactly: </p>
<ul>
<li><code>fault</code> blocks don't have filters like <code>catch</code> blocks do</li>
<li>At the end of a <code>fault</code> block the exception is implicitly rethrown</li>
</ul>
<p id="p5">Supposedly the benefit of a <code>fault</code> block is performance: that <code>throw;</code> statement at the end of a <code>catch</code> block has the same overhead as any other <code>throw</code> statement, whereas <code>finally</code> and <code>fault</code> blocks incur no runtime overhead. The stack is not unwound when a <code>fault</code> block is entered: <code>fault</code> blocks won't appear in the exception stack trace.</p>
<h3>Where do <code>fault</code> blocks show up?</h3>
<p id="p6">In the code the C++/CLI compiler emits in order to make sure that local variables have their destructors called in the event of an exception.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Obscure IEnumerator facts]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/07/obscure-ienumerator-facts.html" />
    <id>http://www.partario.com/blog/2009/07/obscure-ienumerator-facts.html</id>
    <updated>2009-07-28T19:06:26Z</updated>
    <published>2009-07-28T19:06:26Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Obscure IEnumerator facts]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/07/obscure-ienumerator-facts.html"><![CDATA[<p id="p1">Daniel Fortunov wrote about <a href="http://www.danielfortunov.com/software/$daniel_fortunovs_adventures_in_software_development/2009/07/28/duck_typing">an obscure use of duck typing in the C# spec for enumerators</a>:</p>
<blockquote>
<p id="p2">Although it is common to implement [IEnumerable and IEnumerator] when creating an enumerable class, if you were to drop the interfaces but leave the implementation, your class would still be enumerable by foreach. Voila! Duck-typing!</p>
</blockquote>
<p id="p3">You can take advantage of this fact for a couple of performance tricks, as demonstrated by many of the standard collection classes in the base class library:</p>
<ul>
<li>Declare your <code>IEnumerator&lt;T&gt;</code> implementation as a struct, not a class. This saves you a heap allocation when <code>MoveNext</code> is called.</li>
<li>Define a <code>Enumerator&lt;T&gt; GetEnumerator()</code> method on your collection class</li>
<li>Note that you're returning your own struct, not <code>IEnumerable&lt;T&gt;</code>; this avoids a boxing operation. You'll still need to explicitly implement <code>IEnumerator&lt;T&gt; GetEnumerator()</code>, for people who only have an <code>IEnumerable&lt;T&gt;</code> reference to your collection. These performance tricks don't apply when you're making calls through this interface.</li>
</ul>
<p id="p4">When somebody uses <code>foreach</code> over your collection, the compiler sees a series of <code>MoveNext</code> calls and accesses to the <code>Current</code> property, and it emits code to call these efficiently on your struct.</p>
<p id="p5">What's more, the code in your struct's methods is a candidate for <a href="http://blogs.msdn.com/davidnotario/archive/2004/11/01/250398.aspx">inlining by the JIT compiler</a>. The segment of the <code>MoveNext</code> method of <code>System.Collections.Generic.List&lt;T&gt;+Enumerator</code> that can throw an exception is split into its own method, apparently for this reason.</p>
<p id="p6">I don't claim any kind of definite performance benefits from using these techniques, but it does look like the language designers put some thought into making it possible to use <code>foreach</code> without incurring any overhead compared to some less elegant method.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[dollop, a Python Lisp interpreter]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/06/dollop-a-python-lisp-interpreter.html" />
    <id>http://www.partario.com/blog/2009/06/dollop-a-python-lisp-interpreter.html</id>
    <updated>2009-06-15T09:00:02Z</updated>
    <published>2009-06-15T09:00:02Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[dollop, a Python Lisp interpreter]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/06/dollop-a-python-lisp-interpreter.html"><![CDATA[
<p id="p1">Via Hacker News, <a href="http://4.flowsnake.org/archives/602">Hans Nowak's proof of concept</a>:</p>
<blockquote>
  The proof-of-concept implementation that uses this concept is called <a href="http://projects.flowsnake.org/dollop.html">dollop</a> and is available at <a href="http://github.com/zephyrfalcon/dollop/tree/master">github</a>. (Requires Python 3.0.) The name is because it's only a "dollop of Lisp" (or rather, Scheme); it only supports a few special forms (<em>begin</em>, <em>define</em>, <em>if</em>, <em>lambda</em>), and a few functions for example programs (+, -, *, =, <em>list</em>). It cuts corners in other ways as well, as my goal was to get a working proof-of-concept out, not to write a complete Scheme interpreter.
</blockquote>
<p id="p2">Hans explains how he avoids stack overflow, due to tail recursion, by replacing the machine call stack with an explicit stack data structure in his interpreter. A tail call replaces the token at the end of this stack, instead of pushing a new one.</p>
<p id="p3">This is a technique you can apply in an interpreter based around an eval-apply cycle: with a <a href="/blog/2009/06/lisp-compiler-in-f-whats-next.html">full compiler</a>, the principle is the same, but you have to detect tail calls in advance and generate the correct bytecode -- say, a .NET <em>tail.call</em> instruction or an x86 <em>jmp</em> opcode.</p>

]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Vague class names: "Manager" and "Helper"]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/06/vague-class-names-manager-and-helper.html" />
    <id>http://www.partario.com/blog/2009/06/vague-class-names-manager-and-helper.html</id>
    <updated>2009-06-06T18:48:24Z</updated>
    <published>2009-06-06T18:48:24Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Vague class names: "Manager" and "Helper"]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/06/vague-class-names-manager-and-helper.html"><![CDATA[
<p class="alt" id="p1">From <a href="http://journal.stuffwithstuff.com/2009/06/05/naming-things-in-code/">journal.stuffwithstuff.com</a>:</p>
<blockquote>
  <p id="p2">Do not use "Manager" or "Helper" or other null words in a type name.</p>

  <p id="p3">If you need to add "Manager" of "Helper" to a type name, the type is either poorly named or poorly designed. Likely the latter.</p>
</blockquote>
<p id="p4">I always agreed with this: names like <code>ConnectionManager</code> and <code>XmlHelper</code> are too vague to be useful. But I never came up with a retort as pithy as this one of Robert Nystrom's:</p>
<blockquote>
  Types should manage and help themselves.
</blockquote>

]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.partario.com/blog/</uri>
    </author>
    <title type="html"><![CDATA[Moving a Perforce project to GitHub]]></title>
    <link rel="alternate" type="text/html" href="http://www.partario.com/blog/2009/06/moving-a-perforce-project-to-github.html" />
    <id>http://www.partario.com/blog/2009/06/moving-a-perforce-project-to-github.html</id>
    <updated>2009-06-02T20:41:12Z</updated>
    <published>2009-06-02T20:41:12Z</published>
    <category scheme="http://www.partario.com/blog/" term="Uncategorized" />
    <summary type="html"><![CDATA[Moving a Perforce project to GitHub]]></summary>
    <content type="html" xml:base="http://www.partario.com/blog/2009/06/moving-a-perforce-project-to-github.html"><![CDATA[
<p id="p1">I keep all of my home projects in a local <a href="http://www.perforce.com/">Perforce</a> instance. I wanted to put my Lisp compiler code onto <a href="http://github.com/">GitHub</a>; since I'm not paying for a Perforce licence, I'm limited to a single user.</p>
<p id="p2">The GitHub user account and repository setup process was pretty straightforward, until it came to adding files. I haven't been able to find a single set of instructions for this, but I pieced it together thanks to <a href="http://stackoverflow.com/questions/786909/getting-the-whole-files-history-with-p4-git">Stack Overflow</a>:</p>
<ol>
  <li>You will need the <em>git-p4</em> Python script from here: <a href="http://repo.or.cz/w/git.git?a=tree;f=contrib/fast-import;hb=HEAD">http://repo.or.cz/w/git.git?a=tree;f=contrib/fast-import;hb=HEAD</a></li>

  <li>From the some empty directory -- not the one that contains the Perforce project -- run the following command to import the entire Perforce version history:<br/>
  <code>python git-p4 clone --destination=. //depot/path/to/project/...@all</code></li>

  <li>You now have a brand new local git repository that contains a clone of the project from Perforce. You need to push it to GitHub:<br/>
  <code>git remote add origin git@github.com:username/repository.git<br/>
  git push origin master</code></li>

  <li>To push subsequent Perforce changes to GitHub:<br/>
  <code>git-p4 sync<br/>
  git push origin master</code></li>
</ol>
<p id="p3"><strong class="alt">Edit:</strong> I almost forgot to include <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">the URL of the compiler source</a></p>
<p id="p4"><strong class="alt">Edit 2:</strong> Turns out you mustn't run git commands from a Perforce local directory: as always, Perforce doesn't like it if something else (in this case git) interferes with its local files.</p>

]]></content>
  </entry>
</feed>
