


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Tim Robinson</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />

<link rel='stylesheet' href='/css/pygments_murphy.css' type='text/css' />
<link rel='stylesheet' href='/css/pygments_monokai.css' type='text/css' />
<link rel='stylesheet' href='/css/site.css' type='text/css' />
<link rel='stylesheet' href='/css/documentation.css' type='text/css' />
<link rel='stylesheet' href='/css/jquery.tweet.css' type='text/css' />

<script type="text/javascript" src="/js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/js/jquery.tweet.js"></script>
<script type="text/javascript" src="/js/googleRSSWidget.js"></script>
<script type="text/javascript" src="/js/site.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8369986-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  </head>
  <body>
    <div id="content">
      
  
<div id="top_bar">
  <div class="ButtonBar">
      <div id="plugbanner"></div>
      <div id="blog_logo"></div>
      <h1><a href="/blog/">
          <span id="blog_name">
            Tim Robinson
          </span>
        </a>
      </h1>
  </div>
  <div id="search">    
    <form id="searchform" method="get" action="http://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input type="hidden" name="domains" value="www.partario.com">
      <input type="hidden" name="sitesearch" value="www.partario.com">
      <input name="q" id="q" size="20" value="search in blog..." onfocus="if(this.value==this.defaultValue) this.value='';" type="text">
    </form>
  </div>
</div>


      <div id="main_block">
        <div id="prose_block">
          




<div class="blog_post" id="lisp-compiler-in-f#:-il-generation">
  <a class="blog_post_title" name="Lisp compiler in F#: IL generation" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/lisp-compiler-in-f-il-generation.html" rel="bookmark" title="Permanent Link to Lisp compiler in F#: IL generation">Lisp compiler in F#: IL generation</a></h2>
  <small>June 06, 2009 at 02:47 PM | categories: 

<a href='/blog/category/compiler'>Compiler</a>
 | <a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-il-generation.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p id="p1">This is part 4 of a series of posts on my Lisp compiler written in F#. Previous entries: <a href="/blog/2009/05/lisp-compiler-in-f-introduction.html">Introduction</a>, <a href="/blog/2009/05/lisp-compiler-in-f-parsing-with-fslex-and-fsyacc.html">Parsing with fslex and fsyacc</a>, <a href="/blog/2009/06/lisp-compiler-in-f-expression-trees-and-net-methods.html">Expression trees and .NET methods</a> | <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">Browse the full source of the compiler on GitHub</a></p>
<p id="p2">What we've done up to this point is:</p>
<ul>
  <li>Taken a string representing a Lisp program and turned it into an F# data structure representing a list of <a href="http://en.wikipedia.org/wiki/S_expression">s-expressions</a></li>

  <li>Reformatted these s-expressions so we can take some shortcuts when we generate IL</li>

  <li>Written a couple of helper functions that pick the right overload of a .NET method (which our hello world program needs in order to call <code>Console.WriteLine</code>)</li>
</ul>
<p id="p3">In this post I'm going to cover the final step in the compilation process, the generation of the IL itself. By IL, I'm referring to the <a href="http://en.wikipedia.org/wiki/Common_Intermediate_Language">Common Intermediate Language</a>, the low-level machine-independent opcodes that the .NET JIT compiler turns into native machine code at runtime. The virtual machine on which IL is based operates using a stack for operands and results, rather than the registers that are found on x86 processors. (Using a virtual stack makes IL more portable across CPUs with different register layouts; it's up to the JIT compiler to assign machine registers to stack locations as they're needed.) You can view the IL contained within any .NET assembly using the <em>ildasm</em> tool, which is included with Visual Studio and in the .NET SDK, or within <a href="http://www.red-gate.com/products/reflector/">.NET Reflector</a>.</p>
<p id="p4">An IL hello world looks like this:</p>

<div class="pygments_murphy"><pre>// Push a System.String instance onto the stack. 
// The words "Hello world" are embedded within the executable.
ldstr      "Hello, world"

// Pop one System.Object instance from the stack and call 
// System.Console.WriteLine. This method is declared void, so 
// nothing is pushed onto the stack after the method returns.
call       void [mscorlib]System.Console::WriteLine(object)

// Return to this method's caller
ret
</pre></div>



<p id="p5">Along with the IL, the assembly -- an EXE or a DLL -- contains various metadata, which describes the types and methods defined within the assembly (such as the <code>Program</code> class and its <code>Main</code> method that contains our code above, and the words "Hello world"), as well as the references the assembly's code makes to the outside world (such as the details of the <code>System.Console.WriteLine</code> method). We don't have to write any of this metadata ourselves, though: the <code>System.Reflection.Emit</code> namespace contains a nice set of types that allow us to construct assemblies, types and methods without worrying about putting together the bytes of the final EXE or DLL file.</p>
<p id="p6">We put together the IL itself using the <code>ILGenerator</code> class:</p>

<div class="pygments_murphy"><pre><span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldstr</span><span class="o">,</span> <span class="s2">"Hello world"</span><span class="o">)</span>
<span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="nc">Console</span><span class="o">&gt;.</span><span class="nc">GetMethod</span><span class="o">(</span><span class="s2">"WriteLine"</span><span class="o">,</span> <span class="o">[|</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">|]))</span>
<span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ret</span><span class="o">)</span>
</pre></div>



<p id="p7">For the purposes of this blog post, we're going to simplify the code generation even further, and use the <code>DynamicMethod</code> class, which allows us to generate a stream of IL opcodes in memory, then execute them, without having to write a full assembly file to disk. (The code on GitHub demonstrates both approaches -- see <a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/Compiler.fs">Compiler.fs</a> for the code that writes an assembly file.)</p>
<p id="p8">We're going to write the compile function that I talked about in the last post:</p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile</span>
    <span class="o">(</span><span class="n">generator</span> <span class="o">:</span> <span class="nc">ILGenerator</span><span class="o">)</span>
    <span class="o">(</span><span class="n">defineMethod</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nc">Type</span> <span class="o">-&gt;</span> <span class="nc">Type</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">#</span><span class="nc">MethodInfo</span> <span class="o">*</span> <span class="nc">ILGenerator</span><span class="o">)</span>
    <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">,</span> <span class="nc">LispVal</span><span class="o">&gt;)</span>
    <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="nc">LispVal</span><span class="o">)</span> 
    <span class="o">:</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">,</span> <span class="nc">LispVal</span><span class="o">&gt;)</span>
</pre></div>



<p id="p9">We'll have given to us: an <code>ILGenerator</code> instance; a function that creates a new method and returns an <code>ILGenerator</code> for that method; a map containing any variables and functions declared earlier on in this function; and a <code>LispVal</code> representing the line of code we're being asked to generate IL for. We'll return a map containing all of the variables and functions originally passed to us, plus any new variables or functions we might have declared in this line of code.</p>
<p class="alt" id="p10"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/CodeGenerator.fs">CodeGenerator.fs</a></p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile</span> <span class="o">(</span><span class="n">generator</span> <span class="o">:</span> <span class="nc">ILGenerator</span><span class="o">)</span> <span class="n">defineMethod</span> <span class="o">=</span>
</pre></div>



<div class="notice">
  <h2 class="alt">Detour: Currying and partial application</h2>

  <p id="p11">First of all, notice that the F# declaration of the <code>compile</code> function looks nothing like the function interface I just talked about. That's because we're going to define <code>compile</code> as a function that accepts two arguments and returns another function that accepts the next one, which returns yet another function that accepts the last argument and returns a value. In fact, all F# functions work this way, as functions that accept one argument and return another function that accepts the next. From the point of view of the caller, it's not possible to tell the difference between a function written like this:</p>
 

<div class="pygments_murphy"><pre><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span>
        <span class="k">fun</span> <span class="n">b</span> <span class="o">-&gt;</span>
            <span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
                <span class="k">fun</span> <span class="n">d</span> <span class="o">-&gt;</span> 
                    <span class="n">printfn</span> <span class="s2">"called function f with %d %d %d %d"</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span>
</pre></div>




  <p id="p12">and one like this:</p>
 

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">=</span> 
    <span class="n">printfn</span> <span class="s2">"called function f with %d %d %d %d"</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
</pre></div>




  <p id="p13">In the first example, the programmer defines <code>f</code> as a series of functions in which you pass a value to one function in order to obtain the next: in this case, the programmer is said to be <a href="http://en.wikipedia.org/wiki/Currying">currying</a>. In the second example, the programmer states all of <code>f</code>'s parameters on one line, yet we can still call <code>f</code> piece by piece ("partially apply") if we want to: the F# language performs the currying automatically.</p>
</div>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">=</span>
</pre></div>



<p id="p14">So far we've consumed the <code>generator</code>, <code>defineMethod</code> and <code>env</code> parameters. Now we're writing a <code>compile'</code> function, which we're going to use not only when the <code>compile</code> function itself is called, but also recursively from within the <code>compile'</code> function. We do this because we want to be able to generate IL using the same <code>generator</code> and <code>defineMethod</code> parameters originally passed to us, but with different values for <code>env</code> and <code>value</code>.</p>

<div class="pygments_murphy"><pre><span class="k">function</span>
<span class="o">|</span> <span class="nc">ArgRef</span> <span class="n">index</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldarg</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p15"><strong class="alt">ArgRef:</strong> The <code>compile'</code> function immediately performs pattern matching against its last argument: the F# <code>function</code> keyword acts like <code>fun</code> and <code>match</code> combined. We'll handle each of the <code>LispVal</code> cases in alphabetical order: first is <code>ArgRef</code>, which is a value we'll find within a function's environment. There's one of these for each of the function's parameters, and since IL refers to its arguments using numerical indices, so will we. We use the <em>ldarg</em> opcode to fetch the <code>index</code>'th argument and push it onto the VM stack. We don't change the function's environment, so we return <code>env</code> unchanged.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Atom</span> <span class="n">a</span> <span class="o">-&gt;</span> 
    <span class="n">a</span> <span class="o">|&gt;</span> <span class="n">ident</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
</pre></div>



<p id="p16"><strong class="alt">Atom:</strong> An atom is a string that refers to a variable or function in the function's environment. We deal with these by calling <code>ident</code> to look up the string in the current environment, then recursively calling <code>compile'</code> to generate the IL for whatever <code>ident</code> finds. In practice this case is only used for variable and function argument lookups; function names are also atoms, but the only thing we do to functions is call them, and we call functions lower down when we encounter an atom within <code>List</code> node. (In a later version we might want to treat function names that appear outside of function calls like C# does, and turn them into delegates.)</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Bool</span> <span class="n">b</span> <span class="o">-&gt;</span> 
    <span class="k">let</span> <span class="n">opCode</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="n">b</span> 
        <span class="k">then</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4_1</span> 
        <span class="k">else</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4_0</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span> <span class="n">opCode</span>
    <span class="n">env</span>
</pre></div>



<p id="p17"><strong class="alt">Bool:</strong> Bools are the first of our constants to appear. IL represents bools as integers, and it has built-in opcodes whose purpose is to load an integer between 0 and 8 onto the stack, so we generate either <code>ldc.i4.1</code> for true or <code>ldc.i4.0</code> for false here. (Our handling of true and false is completely wrong from a Lisp point of view, which uses <code>nil</code> for false and anything else for true.)</p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="n">emitIf</span> <span class="n">opCode</span> <span class="n">env</span> <span class="n">thenValue</span> <span class="n">elseValue</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">thenLabel</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DefineLabel</span><span class="bp">()</span>
    <span class="k">let</span> <span class="n">endLabel</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DefineLabel</span><span class="bp">()</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="n">opCode</span><span class="o">,</span> <span class="n">thenLabel</span><span class="o">)</span>
    <span class="n">elseValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Br</span><span class="o">,</span> <span class="n">endLabel</span><span class="o">)</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">MarkLabel</span> <span class="n">thenLabel</span>
    <span class="n">thenValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">MarkLabel</span> <span class="n">endLabel</span>

<span class="o">|</span> <span class="nc">IfPrimitive</span> <span class="o">(</span><span class="nc">ListPrimitive</span> <span class="o">(</span><span class="nc">Equal</span><span class="o">,</span> <span class="o">[</span> <span class="n">a</span><span class="o">;</span> <span class="n">b</span> <span class="o">]),</span> <span class="n">thenValue</span><span class="o">,</span> <span class="n">elseValue</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
    <span class="k">let</span> <span class="n">env''</span> <span class="o">=</span> <span class="n">b</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env'</span>
    <span class="n">emitIf</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Beq</span> <span class="n">env''</span> <span class="n">thenValue</span> <span class="n">elseValue</span>
    <span class="n">env''</span>

<span class="o">|</span> <span class="nc">IfPrimitive</span> <span class="o">(</span><span class="n">testValue</span><span class="o">,</span> <span class="n">thenValue</span><span class="o">,</span> <span class="n">elseValue</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">testValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
    <span class="n">emitIf</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Brtrue</span> <span class="n">env'</span> <span class="n">thenValue</span> <span class="n">elseValue</span>
    <span class="n">env'</span>
</pre></div>



<p id="p18"><strong class="alt">IfPrimitive:</strong> The built-in <code>(if test then else)</code> form. There's a special case for <code>(if (= a b) then else)</code>, because IL has its own combined branch-on-equal opcode, <em>beq</em>. If we defined more built-in comparison forms besides <code>Equal</code>, we'd have more special cases here for the other opcodes.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">LambdaDef</span> <span class="o">_</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span>
        <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="s2">"didn't expect lambda outside variable"</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">LambdaRef</span> <span class="o">_</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="s2">"can't compile lambda - try invoking it instead"</span><span class="o">)</span>
</pre></div>



<p id="p19"><strong class="alt">LambdaDef, LambdaRef:</strong> Here we state two limitations on functions: the first happens if we try to use the <code>(lambda)</code> form outside of a variable declaration, and the second occurs if we try to use a function name outside of a function call, which I mentioned above. In a future version we might want to turn these into .NET delegates, although at the moment we have no way of specifying the delegate type (in fact, we have no way to instantiate instances of .NET objects at all).</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">List</span> <span class="o">(</span><span class="nc">Atom</span> <span class="n">a</span> <span class="o">::</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">lambdaIdent</span> <span class="n">args</span> <span class="n">env</span> <span class="n">a</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">LambdaRef</span> <span class="o">(</span><span class="n">methodInfo</span><span class="o">,</span> <span class="n">isParamArray</span><span class="o">,</span> <span class="n">parameterTypes</span><span class="o">)</span> <span class="o">-&gt;</span> 
</pre></div>



<p id="p20"><strong class="alt">List:</strong> Here's where we generate .NET method calls, which in Lisp appear as a list, with the function name (an atom) appearing first, followed by the function's arguments, if any. We start by looking up the function name in the environment and expecting it to resolve to a <code>LambdaRef</code>. I talked about the <code>lambdaIdent</code> function in the last post, and it is this function that picks the right method overload given a set of arguments.</p>

<div class="pygments_murphy"><pre>        <span class="k">let</span> <span class="n">emitBoxed</span> <span class="o">(</span><span class="n">expectedType</span> <span class="o">:</span> <span class="o">#</span><span class="nc">Type</span><span class="o">)</span> <span class="n">env</span> <span class="n">x</span> <span class="o">=</span>
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">compile'</span> <span class="n">env</span> <span class="n">x</span>
            <span class="k">match</span> <span class="n">typeOf</span> <span class="n">env</span> <span class="n">x</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">a</span> <span class="k">when</span> <span class="n">not</span> <span class="n">expectedType</span><span class="o">.</span><span class="nc">IsValueType</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="nc">IsValueType</span> <span class="o">-&gt;</span> 
                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Box</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
                <span class="bp">()</span>

            <span class="n">env'</span>
</pre></div>



<p id="p21">A helper function to automatically <a href="http://en.wikipedia.org/wiki/Boxing_(computer_science)">box</a> instances of value types when needed, so that, for instance, we can pass ints to <code>Console.WriteLine</code>. Note that we need to annotate the F# function signature: <code>expectedType : #Type</code> denotes that <code>expectedType</code> is <code>Type</code>, or one of <code>Type</code>'s subclasses. We do this in order to access its <code>IsValueType</code> property.</p>

<div class="pygments_murphy"><pre>        <span class="k">let</span> <span class="k">rec</span> <span class="n">emitArgs</span> <span class="o">(</span><span class="n">parameterTypes</span> <span class="o">:</span> <span class="o">#</span><span class="nc">Type</span> <span class="kt">list</span><span class="o">)</span> <span class="n">env</span> <span class="n">args</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">args</span><span class="o">,</span> <span class="n">parameterTypes</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span><span class="o">,</span> <span class="o">[</span> <span class="n">parameterType</span> <span class="o">]</span> <span class="k">when</span> <span class="n">isParamArray</span> <span class="o">-&gt;</span>
                <span class="k">let</span> <span class="n">elementType</span> <span class="o">=</span> <span class="n">parameterType</span><span class="o">.</span><span class="nc">GetElementType</span><span class="bp">()</span>

                <span class="k">let</span> <span class="k">rec</span> <span class="n">emitArrayInit</span> <span class="n">env</span> <span class="n">position</span> <span class="o">=</span>
                    <span class="k">function</span>
                    <span class="o">|</span> <span class="n">value</span> <span class="o">::</span> <span class="n">values</span> <span class="o">-&gt;</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Dup</span><span class="o">)</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">)</span>
                        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">emitBoxed</span> <span class="n">elementType</span> <span class="n">env</span> <span class="n">value</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Stelem</span><span class="o">,</span> <span class="n">elementType</span><span class="o">)</span>
                        <span class="n">emitArrayInit</span> <span class="n">env'</span> <span class="o">(</span><span class="n">position</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">values</span>

                    <span class="o">|</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                        <span class="n">env</span>

                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span><span class="o">)</span>
                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Newarr</span><span class="o">,</span> <span class="n">elementType</span><span class="o">)</span>
                <span class="n">emitArrayInit</span> <span class="n">env</span> <span class="mi">0</span> <span class="n">args</span>

            <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span><span class="o">,</span> <span class="n">parameterType</span> <span class="o">::</span> <span class="n">otherParameterTypes</span> <span class="o">-&gt;</span>
                <span class="n">emitArgs</span> <span class="n">otherParameterTypes</span> <span class="o">(</span><span class="n">emitBoxed</span> <span class="n">parameterType</span> <span class="n">env</span> <span class="n">arg</span><span class="o">)</span> <span class="n">otherArgs</span>

            <span class="o">|</span> <span class="o">[</span> <span class="o">],</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                <span class="n">env</span>

            <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="o">_,</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">InvalidOperationException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"got %d too many args"</span> <span class="o">&lt;|</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span><span class="o">)</span>

            <span class="o">|</span> <span class="o">[</span> <span class="o">],</span> <span class="o">_</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> 
                <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">InvalidOperationException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"got %d too few args"</span> <span class="o">&lt;|</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">parameterTypes</span><span class="o">)</span>

        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">args</span> <span class="o">|&gt;</span> <span class="n">emitArgs</span> <span class="n">parameterTypes</span> <span class="n">env</span>
        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">methodInfo</span><span class="o">)</span>
        <span class="n">env'</span>
</pre></div>



<p id="p22">The <code>emitArgs</code> helper function emits the IL to put the function's arguments on the stack. For functions that don't take a variable number of arguments we can do this by calling <code>compile'</code> on each node, since <code>compile'</code> leaves the node's value on the VM stack. Calling variable argument functions (again, such as <code>Console.WriteLine</code>) is slightly more intricate, since the last parameter is an array. We use the <em>newarr</em> opcode to instantiate the array, then <em>stelem</em> in a loop to insert arguments into the array one by one.</p>
<p id="p23">Since we only deal with static functions at the moment (whether they're .NET methods or our own lambdas) it's safe to use the <em>call</em> opcode in all circumstances. If we were calling instance methods we'd need to be able to call virtual methods using <em>callvirt</em>, and we'd need to automatically box value types when calling interface methods (such as <code>4.CompareTo(5)</code>) and methods defined on <code>System.Object</code> (such as <code>4.ToString()</code>). By limiting ourselves to static methods we've avoided these details.</p>

<div class="pygments_murphy"><pre>    <span class="o">|</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="k">raise</span> 
        <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"can't invoke variable %A"</span> <span class="n">v</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">List</span> <span class="o">(</span><span class="n">fn</span> <span class="o">::</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"can't invoke value %A"</span> <span class="n">fn</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">List</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="s2">"can't invoke empty list"</span><span class="o">)</span>
</pre></div>



<p id="p24">Because we don't know about delegates, we can't call anything other than real functions.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">ListPrimitive</span> <span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">match</span> <span class="n">args</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">opCode</span> <span class="o">=</span> 
            <span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nc">Add</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Add</span>
            <span class="o">|</span> <span class="nc">Subtract</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Sub</span>
            <span class="o">|</span> <span class="nc">Multiply</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Mul</span>
            <span class="o">|</span> <span class="nc">Divide</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Div</span>
            <span class="o">|</span> <span class="nc">Equal</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ceq</span>

        <span class="k">let</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">x</span> <span class="o">=</span> 
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">compile'</span> <span class="n">env</span> <span class="n">x</span>
            <span class="k">match</span> <span class="n">typeOf</span> <span class="n">env</span> <span class="n">x</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">t</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="nc">Convert</span><span class="o">&gt;.</span><span class="nc">GetMethod</span><span class="o">(</span><span class="s2">"ToInt32"</span><span class="o">,</span> <span class="o">[|</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">|]))</span>
            <span class="o">|</span> <span class="n">t</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="bp">()</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="s2">"expected int, got "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="nc">Name</span><span class="o">)</span>
            <span class="n">env'</span>

        <span class="k">let</span> <span class="n">emitBinaryOp</span> <span class="n">env</span> <span class="n">arg</span> <span class="o">=</span>
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">arg</span>
            <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span> <span class="n">opCode</span>
            <span class="n">env'</span>

        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">arg</span>
        <span class="n">otherArgs</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">emitBinaryOp</span> <span class="n">env'</span>

    <span class="o">|</span> <span class="n">l</span> <span class="o">-&gt;</span> 
        <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"cannot compile list %A"</span> <span class="n">l</span><span class="o">)</span>
</pre></div>



<p id="p25"><strong class="alt">ListPrimitive:</strong> The built-in forms for arithmetic and equality are defined as <code>ListPrimitive</code> nodes, and the IL for each of these is fairly similar. Note that our arithmetic operators can handle any number of arguments, and we handle this by pushing the first value onto the VM stack, then using F#'s <code>fold</code> function to apply one of IL's binary operators to each pair. We use <code>Convert.ToInt32</code> to coerce any strange values to integers. (Note that <code>List.fold</code> is new in the F# May 2009 CTP -- previously this function was called <code>List.fold_left</code>, to match OCaml.)</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Number</span> <span class="n">n</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
    <span class="n">env</span>

<span class="o">|</span> <span class="nc">String</span> <span class="n">s</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldstr</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p26"><strong class="alt">Number, String:</strong> Another couple of constant types: all numbers are integers, and we use the <em>ldc.i4</em> opcode to push them onto the stack. We saw <em>ldstr</em> in the hello world example at the top of this post.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">VariableDef</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">value</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">LambdaDef</span> <span class="o">(</span><span class="n">paramNames</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">lambdaInfo</span><span class="o">,</span> <span class="n">lambdaGenerator</span><span class="o">)</span> <span class="o">=</span> 
            <span class="n">defineMethod</span>
                <span class="n">name</span>
                <span class="o">(</span><span class="n">typeOf</span> <span class="n">env</span> <span class="n">body</span><span class="o">)</span>
                <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">replicate</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">paramNames</span><span class="o">)</span> <span class="o">(</span><span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;))</span>

        <span class="k">let</span> <span class="n">envWithLambda</span> <span class="o">=</span> 
            <span class="n">env</span> 
            <span class="o">|&gt;</span> <span class="o">(</span><span class="nc">LambdaRef</span> <span class="o">(</span><span class="n">lambdaInfo</span><span class="o">,</span> <span class="bp">false</span><span class="o">,</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;)</span> <span class="n">paramNames</span><span class="o">))</span> 
                <span class="o">|&gt;</span> <span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span><span class="o">)</span>

        <span class="k">let</span> <span class="o">(</span><span class="n">envWithLambdaArgs</span><span class="o">,</span> <span class="o">_)</span> <span class="o">=</span> 
            <span class="n">paramNames</span> 
            <span class="o">|&gt;</span> <span class="o">((</span><span class="n">envWithLambda</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> 
                <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span> <span class="o">(</span><span class="nc">ArgRef</span> <span class="n">index</span><span class="o">)</span> <span class="n">env</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)))</span>

        <span class="n">body</span> <span class="o">|&gt;</span> <span class="n">compile</span> <span class="n">lambdaGenerator</span> <span class="n">defineMethod</span> <span class="n">envWithLambdaArgs</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
        <span class="n">lambdaGenerator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ret</span><span class="o">)</span>
        <span class="n">envWithLambda</span>

    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">local</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DeclareLocal</span><span class="o">(</span><span class="n">typeOf</span> <span class="n">env</span> <span class="n">value</span><span class="o">)</span>
        <span class="k">let</span> <span class="n">envWithVariable</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span> <span class="o">(</span><span class="nc">VariableRef</span> <span class="n">local</span><span class="o">)</span> <span class="n">env</span>
        <span class="n">compile'</span> <span class="n">envWithVariable</span> <span class="n">value</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Stloc</span><span class="o">,</span> <span class="n">local</span><span class="o">)</span>
        <span class="n">envWithVariable</span>
</pre></div>



<p id="p27"><strong class="alt">VariableDef:</strong> We use <code>VariableDef</code> nodes to declare both functions and variables. There are in fact three possibilities here:</p>
<ol>
  <li><code>(define func (arg1 arg2) body)</code></li>

  <li><code>(define func (lambda (arg1 arg2) body))</code></li>

  <li><code>(define variable value)</code></li>
</ol>
<p id="p28">The first two cases are treated the same (in fact, the first case is transformed to the second by <code>insertPrimitives</code>, which we saw in the last post), and both of them define a new named function:</p>
<ol>
  <li>We call <code>defineMethod</code> to obtain a <code>MethodInfo</code> and an <code>ILGenerator</code> for a new method</li>

  <li>So that the function can call itself recursively, we insert the function into the environment before we start generating the function's IL. This changed environment is the one that feeds into the next line of code in the function where the declaration appears.</li>

  <li>We set up a new environment based on the declaring function. This new environment gains a set of <code>ArgRef</code> values that represent the function's arguments.</li>

  <li>We call <code>compile</code> recursively, with the new <code>ILGenerator</code> that <code>defineMethod</code> gave us</li>
</ol>
<div class="notice">
  <h2 class="alt">Detour: Why do we keep a list of parameters if we've got a MethodInfo?</h2>

  <p id="p29">I had originally wanted to represent both our own functions and .NET methods with a .NET <code>MethodInfo</code> object: we need to know the types of the function's parameters in order to call it, and I assumed we could call <code>MethodInfo.GetParameters</code> to obtain them. Unfortunately we're only allowed to call GetParameters on real methods, not <code>DynamicMethod</code> or <code>MethodBuilder</code>, so I had to track the parameter types explicitly.</p>
</div>
<p id="p30">To declare a variable, we first use <code>ILGenerator.DeclareLocal</code> to allocate a new IL local variable, then use the <em>stloc</em> opcode to assign a value to it. As with function declarations, we change the function's environment, and return the changed environment so that it can be fed into the next line of code.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">VariableRef</span> <span class="n">local</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldloc</span><span class="o">,</span> <span class="n">local</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p31"><strong class="alt">VariableRef:</strong> Last in our alphabetical list of expression tree nodes is <code>VariableRef</code>, which is the node we inserted into the environment just a moment ago to represent local variables. IL gives us the <em>ldloc</em> opcode, which fetches the value from a local variable and places it into the VM stack.</p>

<div class="pygments_murphy"><pre><span class="n">compile'</span>
</pre></div>



<p id="p32">In the last line of code, we're outside of the <code>compile'</code> definition and back in <code>compile</code>. Recall that we declared <code>compile</code> as a function that accepts two arguments and returns a function that accepts two more: here we're returning that function.</p>
<p id="p33">To finish up, let's compile the Lisp code I wrote in the last post, which generates most of the features in our code generator:</p>

<div class="pygments_murphy"><pre>(define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))
(Console.WriteLine "6! = {0}" (fact 6))
(Console.WriteLine "What is your name?")
(Console.WriteLine "Hello, {0}" (Console.ReadLine))
</pre></div>



<p class="alt" id="p34">IL disassembly</p>

<div class="pygments_murphy"><pre>.class public auto ansi sealed Program
       extends [mscorlib]System.Object
{
  .method public static void  Main() cil managed
  {
    // (Console.WriteLine "6! = {0}" (fact 6))
    IL_0000:  ldstr      "6! = {0}"
    IL_0005:  ldc.i4     0x6
    IL_000a:  call       int32 Program::fact(int32)
    IL_000f:  box        [mscorlib]System.Int32
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string, object)

    // (Console.WriteLine "What is your name?")
    IL_0019:  ldstr      "What is your name\?"
    IL_001e:  call       void [mscorlib]System.Console::WriteLine(object)

    // (Console.WriteLine "Hello, {0}" (Console.ReadLine))
    IL_0023:  ldstr      "Hello, {0}"
    IL_0028:  call       string [mscorlib]System.Console::ReadLine()
    IL_002d:  call       void [mscorlib]System.Console::WriteLine(string, object)
    IL_0032:  ret
  }

  .method private static int32  fact(int32 A_0) cil managed
  {
    // (if (= n 0) ...
    IL_0000:  ldarg      A_0
    IL_0004:  nop
    IL_0005:  nop
    IL_0006:  ldc.i4     0x0
    IL_000b:  beq        IL_002d

    // else: (* n (fact (- n 1)))
    IL_0010:  ldarg      A_0
    IL_0014:  nop
    IL_0015:  nop
    IL_0016:  ldarg      A_0
    IL_001a:  nop
    IL_001b:  nop
    IL_001c:  ldc.i4     0x1
    IL_0021:  sub
    IL_0022:  call       int32 Program::fact(int32)
    IL_0027:  mul
    IL_0028:  br         IL_0032

    // then: 1
    IL_002d:  ldc.i4     0x1
    IL_0032:  ret
  }
}
</pre></div>



<p id="p35">And just for fun, using Reflector to disassemble into C#:</p>
<p class="alt" id="p36">C# decompilation</p>

<div class="pygments_murphy"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">num1</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="p">(</span><span class="n">num1</span> <span class="p">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">num1</span> <span class="p">-</span> <span class="m">1</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"6! = {0}"</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="m">6</span><span class="p">));</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"What is your name?"</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Hello, {0}"</span><span class="p">,</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>






  </span>
</div>



<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_url = "http://www.partario.com/blog/2009/06/lisp-compiler-in-f-il-generation.html";
</script>
<script type="text/javascript" src="http://disqus.com/forums/timrobinson/embed.js"></script>
<noscript><a href="http://timrobinson.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

        </div><!-- End Prose Block -->
        
  <div class="right_sidebar">
    <div id="right_sidebar">
  <div id="links">
  <h3>About Tim</h3>
  <ul>
      <li><img src="/site_img/icon-github.png" width="16" height="16" alt="Github" valign="middle"/> Github - <a href="https://github.com/timrobinson/">timrobinson</a></li> 
      <li><img src="/site_img/icon-twitter.png" width="16" height="16" alt="Twitter" valign="middle"/> Twitter - <a href="http://twitter.com/tim_g_robinson">@tim_g_robinson</a></li> 
  </ul>
  </div>
  <div id="blog_post_list">
  <h3>Latest blog posts</h3>
  <ul>
    <li><a href="_posts/030.new_npackage_binaries.markdown">New NPackage binaries</a></li>
    <li><a href="_posts/029.this_week_on_npackage.markdown">This week on NPackage</a></li>
    <li><a href="_posts/028.first.markdown">First six NPackage packages</a></li>
    <li><a href="_posts/027.npackage_news.markdown">NPackage news</a></li>
    <li><a href="_posts/026.net_package_manager_feedback.markdown">.NET package manager feedback</a></li>
  </ul>
  </div>
  <div id="categories">
    <h3>Categories</h3>
    <ul>
     <li><a href="/blog/category/uncategorized">Uncategorized</a> (<a href="/blog/category/uncategorized/feed">rss</a>) (17)</li>
     <li><a href="/blog/category/npackage">NPackage</a> (<a href="/blog/category/npackage/feed">rss</a>) (6)</li>
     <li><a href="/blog/category/compiler">Compiler</a> (<a href="/blog/category/compiler/feed">rss</a>) (7)</li>
    </ul>
  </div> 
  <div id="archives">			
    <h3>Archives</h3>
    <ul>
      <li><a href="/blog/archive/2010/05/1" title="May 2010">May 2010</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2010/04/1" title="April 2010">April 2010</a>&nbsp;(5)</li>
      <li><a href="/blog/archive/2010/03/1" title="March 2010">March 2010</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/11/1" title="November 2009">November 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/10/1" title="October 2009">October 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/08/1" title="August 2009">August 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/07/1" title="July 2009">July 2009</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2009/06/1" title="June 2009">June 2009</a>&nbsp;(6)</li>
      <li><a href="/blog/archive/2009/05/1" title="May 2009">May 2009</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2009/04/1" title="April 2009">April 2009</a>&nbsp;(6)</li>
    </ul>
  </div>

</div>

  </div>

      </div><!-- End Main Block -->
      <div id="footer">
        
  <p id="credits">
Powered by <a href="http://www.blogofile.com">Blogofile</a>.<br/>
<br/>
RSS feeds for <a href="http://feeds2.feedburner.com/TimRobinson">Entries</a>
 and <a
href="http://timrobinson.disqus.com/latest.rss">Comments</a>.
<br>
</p>
<script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/timrobinson/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>


      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





