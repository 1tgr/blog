


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Tim Robinson</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />

<link rel='stylesheet' href='/css/pygments_murphy.css' type='text/css' />
<link rel='stylesheet' href='/css/pygments_monokai.css' type='text/css' />
<link rel='stylesheet' href='/css/site.css' type='text/css' />
<link rel='stylesheet' href='/css/documentation.css' type='text/css' />
<link rel='stylesheet' href='/css/jquery.tweet.css' type='text/css' />

<script type="text/javascript" src="/js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/js/jquery.tweet.js"></script>
<script type="text/javascript" src="/js/googleRSSWidget.js"></script>
<script type="text/javascript" src="/js/site.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8369986-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  </head>
  <body>
    <div id="content">
      
  
<div id="top_bar">
  <div class="ButtonBar">
      <div id="plugbanner"></div>
      <div id="blog_logo"></div>
      <h1><a href="/blog/">
          <span id="blog_name">
            Tim Robinson
          </span>
        </a>
      </h1>
  </div>
  <div id="search">    
    <form id="searchform" method="get" action="http://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input type="hidden" name="domains" value="www.partario.com">
      <input type="hidden" name="sitesearch" value="www.partario.com">
      <input name="q" id="q" size="20" value="search in blog..." onfocus="if(this.value==this.defaultValue) this.value='';" type="text">
    </form>
  </div>
</div>


      <div id="main_block">
        <div id="prose_block">
          
  



<div class="blog_post" id="dollop,-a-python-lisp-interpreter">
  <a class="blog_post_title" name="dollop, a Python Lisp interpreter" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/dollop-a-python-lisp-interpreter.html" rel="bookmark" title="Permanent Link to dollop, a Python Lisp interpreter">dollop, a Python Lisp interpreter</a></h2>
  <small>June 15, 2009 at 09:00 AM | categories: 

<a href='/blog/category/uncategorized'>Uncategorized</a>
 | <a href="http://www.partario.com/blog/2009/06/dollop-a-python-lisp-interpreter.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p id="p1">Via Hacker News, <a href="http://4.flowsnake.org/archives/602">Hans Nowak's proof of concept</a>:</p>
<blockquote>
  The proof-of-concept implementation that uses this concept is called <a href="http://projects.flowsnake.org/dollop.html">dollop</a> and is available at <a href="http://github.com/zephyrfalcon/dollop/tree/master">github</a>. (Requires Python 3.0.) The name is because it's only a "dollop of Lisp" (or rather, Scheme); it only supports a few special forms (<em>begin</em>, <em>define</em>, <em>if</em>, <em>lambda</em>), and a few functions for example programs (+, -, *, =, <em>list</em>). It cuts corners in other ways as well, as my goal was to get a working proof-of-concept out, not to write a complete Scheme interpreter.
</blockquote>
<p id="p2">Hans explains how he avoids stack overflow, due to tail recursion, by replacing the machine call stack with an explicit stack data structure in his interpreter. A tail call replaces the token at the end of this stack, instead of pushing a new one.</p>
<p id="p3">This is a technique you can apply in an interpreter based around an eval-apply cycle: with a <a href="/blog/2009/06/lisp-compiler-in-f-whats-next.html">full compiler</a>, the principle is the same, but you have to detect tail calls in advance and generate the correct bytecode -- say, a .NET <em>tail.call</em> instruction or an x86 <em>jmp</em> opcode.</p>



  </span>
</div>



  <div class="after_post"><a href="http://www.partario.com/blog/2009/06/dollop-a-python-lisp-interpreter.html#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  



<div class="blog_post" id="lisp-compiler-in-f#:-what's-next-">
  <a class="blog_post_title" name="Lisp compiler in F#: What's next?" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/lisp-compiler-in-f-whats-next.html" rel="bookmark" title="Permanent Link to Lisp compiler in F#: What's next?">Lisp compiler in F#: What's next?</a></h2>
  <small>June 09, 2009 at 11:12 PM | categories: 

<a href='/blog/category/compiler'>Compiler</a>
 | <a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-whats-next.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p id="p1">This is part 5 of a series of posts on my Lisp compiler written in F#. Previous entries: <a href="/blog/2009/05/lisp-compiler-in-f-introduction.html">Introduction</a>, <a href="/blog/2009/05/lisp-compiler-in-f-parsing-with-fslex-and-fsyacc.html">Parsing with fslex and fsyacc</a>, <a href="/blog/2009/06/lisp-compiler-in-f-expression-trees-and-net-methods.html">Expression trees and .NET methods</a>, <a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-il-generation.html">IL generation</a> | <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">Browse the full source of the compiler on GitHub</a></p>
<p id="p2">This post marks the end of the first series of Lisp compiler posts, since we're at the point where the code does something useful while still being compact enough to explain in a few blog posts. In the future it should make an interesting test bed for learning about compiler techniques, which I hope to cover here.</p>
<p id="p3">Here's some of the ideas I'd like to try out:</p>
<ul>
  <li>Implement all the Lisp functionality from Jonathan Tang's <a href="http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html">Write Yourself a Scheme in 48 Hours</a> tutorial. Jonathan explains how to implement a Scheme interpreter in Haskell, which is a similar goal to my Scheme-like compiler in F#. (It was actually his tutorial that first gave me the idea of doing it in F#.)</li>

  <li>.NET integration:

    <ul>
      <li>Ability to create new .NET objects, call instance methods, and access properties and events. Currently we're restricted to static methods.</li>

      <li>Ability to define your own .NET classes. One thing I'd like to be able to do is implement the NUnit tests for this project directly in Lisp, which means the compiler needs to be able to generate instance methods with custom attributes applied.</li>

      <li>A full System.CodeDom.Compiler implementation: Lisp on ASP.NET anyone?</li>
    </ul>
  </li>

  <li>Optimisations:

    <ul>
      <li><p id="p4">Tail call optimisation: replace the <em>call</em>, <em>ret</em> sequence with <em>tail.call</em>, <em>ret</em>. This is less an optmisation and more a necessity, since recursion is currently the only way to implement looping, and we need tail calls to avoid overflowing the stack. The <em>tail</em> opcode prefix is recognised directly by the CLR: another approach would be for the compiler to implement a recursive function as a <code>while</code> loop. Tail calling on .NET is a moderately interesting topic in its own right: see the links from <a href="http://stackoverflow.com/questions/491376/why-doesnt-net-c-eliminate-tail-recursion">this Stack Overflow question</a> to get an idea of the issues involved.</p>
<p id="p5"><strong class="alt">Edit:</strong> as <a href="http://www.paulhollingsworth.com/">Paul</a> points out, the trick is to optimise all tail calls, not just tail recursion. It's easy to come up with a pair of functions that call each other: if we just looked for recursive calls back to the same function, we'd blow up the stack in this situation. Luckily for us, the IL <em>tail</em> prefix is valid on any call, as long as it comes just before a <em>ret</em>, so we don't need to be too clever.</p></li>

      <li>Arithmetic optimisations: something as simple as simplifying constant expressions at compile time</li>
    </ul>
  </li>

  <li>A command line compiler, with parameters similar to those of <em>csc.exe</em> or <em>fsc.exe</em></li>

  <li>Don't generate IL directly to <code>ILGenerator</code>; assemble F# data structures representing the IL, so that we can apply IL optimisations using standard F# constructs such as pattern matching</li>

  <li>Implement flow control within the compiler on top of a flow control graph data structure, along the lines of <a href="http://en.wikipedia.org/wiki/Basic_block">basic blocks</a>. This will make optimisations of program flow easier to implement.</li>
</ul>
<p id="p6">Let me know if you've found this series useful so far, or if you have any corrections or suggestions on what I've been writing.</p>


  </span>
</div>



  <div class="after_post"><a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-whats-next.html#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  



<div class="blog_post" id="vague-class-names:-"manager"-and-"helper"">
  <a class="blog_post_title" name="Vague class names: "Manager" and "Helper"" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/vague-class-names-manager-and-helper.html" rel="bookmark" title="Permanent Link to Vague class names: "Manager" and "Helper"">Vague class names: "Manager" and "Helper"</a></h2>
  <small>June 06, 2009 at 06:48 PM | categories: 

<a href='/blog/category/uncategorized'>Uncategorized</a>
 | <a href="http://www.partario.com/blog/2009/06/vague-class-names-manager-and-helper.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p class="alt" id="p1">From <a href="http://journal.stuffwithstuff.com/2009/06/05/naming-things-in-code/">journal.stuffwithstuff.com</a>:</p>
<blockquote>
  <p id="p2">Do not use "Manager" or "Helper" or other null words in a type name.</p>

  <p id="p3">If you need to add "Manager" of "Helper" to a type name, the type is either poorly named or poorly designed. Likely the latter.</p>
</blockquote>
<p id="p4">I always agreed with this: names like <code>ConnectionManager</code> and <code>XmlHelper</code> are too vague to be useful. But I never came up with a retort as pithy as this one of Robert Nystrom's:</p>
<blockquote>
  Types should manage and help themselves.
</blockquote>



  </span>
</div>



  <div class="after_post"><a href="http://www.partario.com/blog/2009/06/vague-class-names-manager-and-helper.html#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  



<div class="blog_post" id="lisp-compiler-in-f#:-il-generation">
  <a class="blog_post_title" name="Lisp compiler in F#: IL generation" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/lisp-compiler-in-f-il-generation.html" rel="bookmark" title="Permanent Link to Lisp compiler in F#: IL generation">Lisp compiler in F#: IL generation</a></h2>
  <small>June 06, 2009 at 02:47 PM | categories: 

<a href='/blog/category/compiler'>Compiler</a>
 | <a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-il-generation.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p id="p1">This is part 4 of a series of posts on my Lisp compiler written in F#. Previous entries: <a href="/blog/2009/05/lisp-compiler-in-f-introduction.html">Introduction</a>, <a href="/blog/2009/05/lisp-compiler-in-f-parsing-with-fslex-and-fsyacc.html">Parsing with fslex and fsyacc</a>, <a href="/blog/2009/06/lisp-compiler-in-f-expression-trees-and-net-methods.html">Expression trees and .NET methods</a> | <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">Browse the full source of the compiler on GitHub</a></p>
<p id="p2">What we've done up to this point is:</p>
<ul>
  <li>Taken a string representing a Lisp program and turned it into an F# data structure representing a list of <a href="http://en.wikipedia.org/wiki/S_expression">s-expressions</a></li>

  <li>Reformatted these s-expressions so we can take some shortcuts when we generate IL</li>

  <li>Written a couple of helper functions that pick the right overload of a .NET method (which our hello world program needs in order to call <code>Console.WriteLine</code>)</li>
</ul>
<p id="p3">In this post I'm going to cover the final step in the compilation process, the generation of the IL itself. By IL, I'm referring to the <a href="http://en.wikipedia.org/wiki/Common_Intermediate_Language">Common Intermediate Language</a>, the low-level machine-independent opcodes that the .NET JIT compiler turns into native machine code at runtime. The virtual machine on which IL is based operates using a stack for operands and results, rather than the registers that are found on x86 processors. (Using a virtual stack makes IL more portable across CPUs with different register layouts; it's up to the JIT compiler to assign machine registers to stack locations as they're needed.) You can view the IL contained within any .NET assembly using the <em>ildasm</em> tool, which is included with Visual Studio and in the .NET SDK, or within <a href="http://www.red-gate.com/products/reflector/">.NET Reflector</a>.</p>
<p id="p4">An IL hello world looks like this:</p>

<div class="pygments_murphy"><pre>// Push a System.String instance onto the stack. 
// The words "Hello world" are embedded within the executable.
ldstr      "Hello, world"

// Pop one System.Object instance from the stack and call 
// System.Console.WriteLine. This method is declared void, so 
// nothing is pushed onto the stack after the method returns.
call       void [mscorlib]System.Console::WriteLine(object)

// Return to this method's caller
ret
</pre></div>



<p id="p5">Along with the IL, the assembly -- an EXE or a DLL -- contains various metadata, which describes the types and methods defined within the assembly (such as the <code>Program</code> class and its <code>Main</code> method that contains our code above, and the words "Hello world"), as well as the references the assembly's code makes to the outside world (such as the details of the <code>System.Console.WriteLine</code> method). We don't have to write any of this metadata ourselves, though: the <code>System.Reflection.Emit</code> namespace contains a nice set of types that allow us to construct assemblies, types and methods without worrying about putting together the bytes of the final EXE or DLL file.</p>
<p id="p6">We put together the IL itself using the <code>ILGenerator</code> class:</p>

<div class="pygments_murphy"><pre><span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldstr</span><span class="o">,</span> <span class="s2">"Hello world"</span><span class="o">)</span>
<span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="nc">Console</span><span class="o">&gt;.</span><span class="nc">GetMethod</span><span class="o">(</span><span class="s2">"WriteLine"</span><span class="o">,</span> <span class="o">[|</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">|]))</span>
<span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ret</span><span class="o">)</span>
</pre></div>



<p id="p7">For the purposes of this blog post, we're going to simplify the code generation even further, and use the <code>DynamicMethod</code> class, which allows us to generate a stream of IL opcodes in memory, then execute them, without having to write a full assembly file to disk. (The code on GitHub demonstrates both approaches -- see <a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/Compiler.fs">Compiler.fs</a> for the code that writes an assembly file.)</p>
<p id="p8">We're going to write the compile function that I talked about in the last post:</p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile</span>
    <span class="o">(</span><span class="n">generator</span> <span class="o">:</span> <span class="nc">ILGenerator</span><span class="o">)</span>
    <span class="o">(</span><span class="n">defineMethod</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nc">Type</span> <span class="o">-&gt;</span> <span class="nc">Type</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">#</span><span class="nc">MethodInfo</span> <span class="o">*</span> <span class="nc">ILGenerator</span><span class="o">)</span>
    <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">,</span> <span class="nc">LispVal</span><span class="o">&gt;)</span>
    <span class="o">(</span><span class="n">value</span> <span class="o">:</span> <span class="nc">LispVal</span><span class="o">)</span> 
    <span class="o">:</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">,</span> <span class="nc">LispVal</span><span class="o">&gt;)</span>
</pre></div>



<p id="p9">We'll have given to us: an <code>ILGenerator</code> instance; a function that creates a new method and returns an <code>ILGenerator</code> for that method; a map containing any variables and functions declared earlier on in this function; and a <code>LispVal</code> representing the line of code we're being asked to generate IL for. We'll return a map containing all of the variables and functions originally passed to us, plus any new variables or functions we might have declared in this line of code.</p>
<p class="alt" id="p10"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/CodeGenerator.fs">CodeGenerator.fs</a></p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile</span> <span class="o">(</span><span class="n">generator</span> <span class="o">:</span> <span class="nc">ILGenerator</span><span class="o">)</span> <span class="n">defineMethod</span> <span class="o">=</span>
</pre></div>



<div class="notice">
  <h2 class="alt">Detour: Currying and partial application</h2>

  <p id="p11">First of all, notice that the F# declaration of the <code>compile</code> function looks nothing like the function interface I just talked about. That's because we're going to define <code>compile</code> as a function that accepts two arguments and returns another function that accepts the next one, which returns yet another function that accepts the last argument and returns a value. In fact, all F# functions work this way, as functions that accept one argument and return another function that accepts the next. From the point of view of the caller, it's not possible to tell the difference between a function written like this:</p>
 

<div class="pygments_murphy"><pre><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span>
        <span class="k">fun</span> <span class="n">b</span> <span class="o">-&gt;</span>
            <span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
                <span class="k">fun</span> <span class="n">d</span> <span class="o">-&gt;</span> 
                    <span class="n">printfn</span> <span class="s2">"called function f with %d %d %d %d"</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span>
</pre></div>




  <p id="p12">and one like this:</p>
 

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">=</span> 
    <span class="n">printfn</span> <span class="s2">"called function f with %d %d %d %d"</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
</pre></div>




  <p id="p13">In the first example, the programmer defines <code>f</code> as a series of functions in which you pass a value to one function in order to obtain the next: in this case, the programmer is said to be <a href="http://en.wikipedia.org/wiki/Currying">currying</a>. In the second example, the programmer states all of <code>f</code>'s parameters on one line, yet we can still call <code>f</code> piece by piece ("partially apply") if we want to: the F# language performs the currying automatically.</p>
</div>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">=</span>
</pre></div>



<p id="p14">So far we've consumed the <code>generator</code>, <code>defineMethod</code> and <code>env</code> parameters. Now we're writing a <code>compile'</code> function, which we're going to use not only when the <code>compile</code> function itself is called, but also recursively from within the <code>compile'</code> function. We do this because we want to be able to generate IL using the same <code>generator</code> and <code>defineMethod</code> parameters originally passed to us, but with different values for <code>env</code> and <code>value</code>.</p>

<div class="pygments_murphy"><pre><span class="k">function</span>
<span class="o">|</span> <span class="nc">ArgRef</span> <span class="n">index</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldarg</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p15"><strong class="alt">ArgRef:</strong> The <code>compile'</code> function immediately performs pattern matching against its last argument: the F# <code>function</code> keyword acts like <code>fun</code> and <code>match</code> combined. We'll handle each of the <code>LispVal</code> cases in alphabetical order: first is <code>ArgRef</code>, which is a value we'll find within a function's environment. There's one of these for each of the function's parameters, and since IL refers to its arguments using numerical indices, so will we. We use the <em>ldarg</em> opcode to fetch the <code>index</code>'th argument and push it onto the VM stack. We don't change the function's environment, so we return <code>env</code> unchanged.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Atom</span> <span class="n">a</span> <span class="o">-&gt;</span> 
    <span class="n">a</span> <span class="o">|&gt;</span> <span class="n">ident</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
</pre></div>



<p id="p16"><strong class="alt">Atom:</strong> An atom is a string that refers to a variable or function in the function's environment. We deal with these by calling <code>ident</code> to look up the string in the current environment, then recursively calling <code>compile'</code> to generate the IL for whatever <code>ident</code> finds. In practice this case is only used for variable and function argument lookups; function names are also atoms, but the only thing we do to functions is call them, and we call functions lower down when we encounter an atom within <code>List</code> node. (In a later version we might want to treat function names that appear outside of function calls like C# does, and turn them into delegates.)</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Bool</span> <span class="n">b</span> <span class="o">-&gt;</span> 
    <span class="k">let</span> <span class="n">opCode</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="n">b</span> 
        <span class="k">then</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4_1</span> 
        <span class="k">else</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4_0</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span> <span class="n">opCode</span>
    <span class="n">env</span>
</pre></div>



<p id="p17"><strong class="alt">Bool:</strong> Bools are the first of our constants to appear. IL represents bools as integers, and it has built-in opcodes whose purpose is to load an integer between 0 and 8 onto the stack, so we generate either <code>ldc.i4.1</code> for true or <code>ldc.i4.0</code> for false here. (Our handling of true and false is completely wrong from a Lisp point of view, which uses <code>nil</code> for false and anything else for true.)</p>

<div class="pygments_murphy"><pre><span class="k">let</span> <span class="n">emitIf</span> <span class="n">opCode</span> <span class="n">env</span> <span class="n">thenValue</span> <span class="n">elseValue</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">thenLabel</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DefineLabel</span><span class="bp">()</span>
    <span class="k">let</span> <span class="n">endLabel</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DefineLabel</span><span class="bp">()</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="n">opCode</span><span class="o">,</span> <span class="n">thenLabel</span><span class="o">)</span>
    <span class="n">elseValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Br</span><span class="o">,</span> <span class="n">endLabel</span><span class="o">)</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">MarkLabel</span> <span class="n">thenLabel</span>
    <span class="n">thenValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
    <span class="n">generator</span><span class="o">.</span><span class="nc">MarkLabel</span> <span class="n">endLabel</span>

<span class="o">|</span> <span class="nc">IfPrimitive</span> <span class="o">(</span><span class="nc">ListPrimitive</span> <span class="o">(</span><span class="nc">Equal</span><span class="o">,</span> <span class="o">[</span> <span class="n">a</span><span class="o">;</span> <span class="n">b</span> <span class="o">]),</span> <span class="n">thenValue</span><span class="o">,</span> <span class="n">elseValue</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
    <span class="k">let</span> <span class="n">env''</span> <span class="o">=</span> <span class="n">b</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env'</span>
    <span class="n">emitIf</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Beq</span> <span class="n">env''</span> <span class="n">thenValue</span> <span class="n">elseValue</span>
    <span class="n">env''</span>

<span class="o">|</span> <span class="nc">IfPrimitive</span> <span class="o">(</span><span class="n">testValue</span><span class="o">,</span> <span class="n">thenValue</span><span class="o">,</span> <span class="n">elseValue</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">testValue</span> <span class="o">|&gt;</span> <span class="n">compile'</span> <span class="n">env</span>
    <span class="n">emitIf</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Brtrue</span> <span class="n">env'</span> <span class="n">thenValue</span> <span class="n">elseValue</span>
    <span class="n">env'</span>
</pre></div>



<p id="p18"><strong class="alt">IfPrimitive:</strong> The built-in <code>(if test then else)</code> form. There's a special case for <code>(if (= a b) then else)</code>, because IL has its own combined branch-on-equal opcode, <em>beq</em>. If we defined more built-in comparison forms besides <code>Equal</code>, we'd have more special cases here for the other opcodes.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">LambdaDef</span> <span class="o">_</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span>
        <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="s2">"didn't expect lambda outside variable"</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">LambdaRef</span> <span class="o">_</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="s2">"can't compile lambda - try invoking it instead"</span><span class="o">)</span>
</pre></div>



<p id="p19"><strong class="alt">LambdaDef, LambdaRef:</strong> Here we state two limitations on functions: the first happens if we try to use the <code>(lambda)</code> form outside of a variable declaration, and the second occurs if we try to use a function name outside of a function call, which I mentioned above. In a future version we might want to turn these into .NET delegates, although at the moment we have no way of specifying the delegate type (in fact, we have no way to instantiate instances of .NET objects at all).</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">List</span> <span class="o">(</span><span class="nc">Atom</span> <span class="n">a</span> <span class="o">::</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">lambdaIdent</span> <span class="n">args</span> <span class="n">env</span> <span class="n">a</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">LambdaRef</span> <span class="o">(</span><span class="n">methodInfo</span><span class="o">,</span> <span class="n">isParamArray</span><span class="o">,</span> <span class="n">parameterTypes</span><span class="o">)</span> <span class="o">-&gt;</span> 
</pre></div>



<p id="p20"><strong class="alt">List:</strong> Here's where we generate .NET method calls, which in Lisp appear as a list, with the function name (an atom) appearing first, followed by the function's arguments, if any. We start by looking up the function name in the environment and expecting it to resolve to a <code>LambdaRef</code>. I talked about the <code>lambdaIdent</code> function in the last post, and it is this function that picks the right method overload given a set of arguments.</p>

<div class="pygments_murphy"><pre>        <span class="k">let</span> <span class="n">emitBoxed</span> <span class="o">(</span><span class="n">expectedType</span> <span class="o">:</span> <span class="o">#</span><span class="nc">Type</span><span class="o">)</span> <span class="n">env</span> <span class="n">x</span> <span class="o">=</span>
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">compile'</span> <span class="n">env</span> <span class="n">x</span>
            <span class="k">match</span> <span class="n">typeOf</span> <span class="n">env</span> <span class="n">x</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">a</span> <span class="k">when</span> <span class="n">not</span> <span class="n">expectedType</span><span class="o">.</span><span class="nc">IsValueType</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="nc">IsValueType</span> <span class="o">-&gt;</span> 
                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Box</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
                <span class="bp">()</span>

            <span class="n">env'</span>
</pre></div>



<p id="p21">A helper function to automatically <a href="http://en.wikipedia.org/wiki/Boxing_(computer_science)">box</a> instances of value types when needed, so that, for instance, we can pass ints to <code>Console.WriteLine</code>. Note that we need to annotate the F# function signature: <code>expectedType : #Type</code> denotes that <code>expectedType</code> is <code>Type</code>, or one of <code>Type</code>'s subclasses. We do this in order to access its <code>IsValueType</code> property.</p>

<div class="pygments_murphy"><pre>        <span class="k">let</span> <span class="k">rec</span> <span class="n">emitArgs</span> <span class="o">(</span><span class="n">parameterTypes</span> <span class="o">:</span> <span class="o">#</span><span class="nc">Type</span> <span class="kt">list</span><span class="o">)</span> <span class="n">env</span> <span class="n">args</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">args</span><span class="o">,</span> <span class="n">parameterTypes</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span><span class="o">,</span> <span class="o">[</span> <span class="n">parameterType</span> <span class="o">]</span> <span class="k">when</span> <span class="n">isParamArray</span> <span class="o">-&gt;</span>
                <span class="k">let</span> <span class="n">elementType</span> <span class="o">=</span> <span class="n">parameterType</span><span class="o">.</span><span class="nc">GetElementType</span><span class="bp">()</span>

                <span class="k">let</span> <span class="k">rec</span> <span class="n">emitArrayInit</span> <span class="n">env</span> <span class="n">position</span> <span class="o">=</span>
                    <span class="k">function</span>
                    <span class="o">|</span> <span class="n">value</span> <span class="o">::</span> <span class="n">values</span> <span class="o">-&gt;</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Dup</span><span class="o">)</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">)</span>
                        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">emitBoxed</span> <span class="n">elementType</span> <span class="n">env</span> <span class="n">value</span>
                        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Stelem</span><span class="o">,</span> <span class="n">elementType</span><span class="o">)</span>
                        <span class="n">emitArrayInit</span> <span class="n">env'</span> <span class="o">(</span><span class="n">position</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">values</span>

                    <span class="o">|</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                        <span class="n">env</span>

                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span><span class="o">)</span>
                <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Newarr</span><span class="o">,</span> <span class="n">elementType</span><span class="o">)</span>
                <span class="n">emitArrayInit</span> <span class="n">env</span> <span class="mi">0</span> <span class="n">args</span>

            <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span><span class="o">,</span> <span class="n">parameterType</span> <span class="o">::</span> <span class="n">otherParameterTypes</span> <span class="o">-&gt;</span>
                <span class="n">emitArgs</span> <span class="n">otherParameterTypes</span> <span class="o">(</span><span class="n">emitBoxed</span> <span class="n">parameterType</span> <span class="n">env</span> <span class="n">arg</span><span class="o">)</span> <span class="n">otherArgs</span>

            <span class="o">|</span> <span class="o">[</span> <span class="o">],</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                <span class="n">env</span>

            <span class="o">|</span> <span class="o">_</span> <span class="o">::</span> <span class="o">_,</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
                <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">InvalidOperationException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"got %d too many args"</span> <span class="o">&lt;|</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span><span class="o">)</span>

            <span class="o">|</span> <span class="o">[</span> <span class="o">],</span> <span class="o">_</span> <span class="o">::</span> <span class="o">_</span> <span class="o">-&gt;</span> 
                <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">InvalidOperationException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"got %d too few args"</span> <span class="o">&lt;|</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">parameterTypes</span><span class="o">)</span>

        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">args</span> <span class="o">|&gt;</span> <span class="n">emitArgs</span> <span class="n">parameterTypes</span> <span class="n">env</span>
        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">methodInfo</span><span class="o">)</span>
        <span class="n">env'</span>
</pre></div>



<p id="p22">The <code>emitArgs</code> helper function emits the IL to put the function's arguments on the stack. For functions that don't take a variable number of arguments we can do this by calling <code>compile'</code> on each node, since <code>compile'</code> leaves the node's value on the VM stack. Calling variable argument functions (again, such as <code>Console.WriteLine</code>) is slightly more intricate, since the last parameter is an array. We use the <em>newarr</em> opcode to instantiate the array, then <em>stelem</em> in a loop to insert arguments into the array one by one.</p>
<p id="p23">Since we only deal with static functions at the moment (whether they're .NET methods or our own lambdas) it's safe to use the <em>call</em> opcode in all circumstances. If we were calling instance methods we'd need to be able to call virtual methods using <em>callvirt</em>, and we'd need to automatically box value types when calling interface methods (such as <code>4.CompareTo(5)</code>) and methods defined on <code>System.Object</code> (such as <code>4.ToString()</code>). By limiting ourselves to static methods we've avoided these details.</p>

<div class="pygments_murphy"><pre>    <span class="o">|</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="k">raise</span> 
        <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"can't invoke variable %A"</span> <span class="n">v</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">List</span> <span class="o">(</span><span class="n">fn</span> <span class="o">::</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"can't invoke value %A"</span> <span class="n">fn</span><span class="o">)</span>

<span class="o">|</span> <span class="nc">List</span> <span class="o">[</span> <span class="o">]</span> <span class="o">-&gt;</span> 
    <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="s2">"can't invoke empty list"</span><span class="o">)</span>
</pre></div>



<p id="p24">Because we don't know about delegates, we can't call anything other than real functions.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">ListPrimitive</span> <span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">match</span> <span class="n">args</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">arg</span> <span class="o">::</span> <span class="n">otherArgs</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">opCode</span> <span class="o">=</span> 
            <span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nc">Add</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Add</span>
            <span class="o">|</span> <span class="nc">Subtract</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Sub</span>
            <span class="o">|</span> <span class="nc">Multiply</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Mul</span>
            <span class="o">|</span> <span class="nc">Divide</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Div</span>
            <span class="o">|</span> <span class="nc">Equal</span> <span class="o">-&gt;</span> <span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ceq</span>

        <span class="k">let</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">x</span> <span class="o">=</span> 
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">compile'</span> <span class="n">env</span> <span class="n">x</span>
            <span class="k">match</span> <span class="n">typeOf</span> <span class="n">env</span> <span class="n">x</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">t</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Call</span><span class="o">,</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="nc">Convert</span><span class="o">&gt;.</span><span class="nc">GetMethod</span><span class="o">(</span><span class="s2">"ToInt32"</span><span class="o">,</span> <span class="o">[|</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="o">|]))</span>
            <span class="o">|</span> <span class="n">t</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="bp">()</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span class="nc">NotImplementedException</span><span class="o">(</span><span class="s2">"expected int, got "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="nc">Name</span><span class="o">)</span>
            <span class="n">env'</span>

        <span class="k">let</span> <span class="n">emitBinaryOp</span> <span class="n">env</span> <span class="n">arg</span> <span class="o">=</span>
            <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">arg</span>
            <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span> <span class="n">opCode</span>
            <span class="n">env'</span>

        <span class="k">let</span> <span class="n">env'</span> <span class="o">=</span> <span class="n">coerceToInt</span> <span class="n">env</span> <span class="n">arg</span>
        <span class="n">otherArgs</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">emitBinaryOp</span> <span class="n">env'</span>

    <span class="o">|</span> <span class="n">l</span> <span class="o">-&gt;</span> 
        <span class="k">raise</span> <span class="o">&lt;|</span> <span class="nc">Compiler</span><span class="o">(</span><span class="n">sprintf</span> <span class="s2">"cannot compile list %A"</span> <span class="n">l</span><span class="o">)</span>
</pre></div>



<p id="p25"><strong class="alt">ListPrimitive:</strong> The built-in forms for arithmetic and equality are defined as <code>ListPrimitive</code> nodes, and the IL for each of these is fairly similar. Note that our arithmetic operators can handle any number of arguments, and we handle this by pushing the first value onto the VM stack, then using F#'s <code>fold</code> function to apply one of IL's binary operators to each pair. We use <code>Convert.ToInt32</code> to coerce any strange values to integers. (Note that <code>List.fold</code> is new in the F# May 2009 CTP -- previously this function was called <code>List.fold_left</code>, to match OCaml.)</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">Number</span> <span class="n">n</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldc_I4</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
    <span class="n">env</span>

<span class="o">|</span> <span class="nc">String</span> <span class="n">s</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldstr</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p26"><strong class="alt">Number, String:</strong> Another couple of constant types: all numbers are integers, and we use the <em>ldc.i4</em> opcode to push them onto the stack. We saw <em>ldstr</em> in the hello world example at the top of this post.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">VariableDef</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">value</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">LambdaDef</span> <span class="o">(</span><span class="n">paramNames</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">lambdaInfo</span><span class="o">,</span> <span class="n">lambdaGenerator</span><span class="o">)</span> <span class="o">=</span> 
            <span class="n">defineMethod</span>
                <span class="n">name</span>
                <span class="o">(</span><span class="n">typeOf</span> <span class="n">env</span> <span class="n">body</span><span class="o">)</span>
                <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">replicate</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">paramNames</span><span class="o">)</span> <span class="o">(</span><span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;))</span>

        <span class="k">let</span> <span class="n">envWithLambda</span> <span class="o">=</span> 
            <span class="n">env</span> 
            <span class="o">|&gt;</span> <span class="o">(</span><span class="nc">LambdaRef</span> <span class="o">(</span><span class="n">lambdaInfo</span><span class="o">,</span> <span class="bp">false</span><span class="o">,</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;)</span> <span class="n">paramNames</span><span class="o">))</span> 
                <span class="o">|&gt;</span> <span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span><span class="o">)</span>

        <span class="k">let</span> <span class="o">(</span><span class="n">envWithLambdaArgs</span><span class="o">,</span> <span class="o">_)</span> <span class="o">=</span> 
            <span class="n">paramNames</span> 
            <span class="o">|&gt;</span> <span class="o">((</span><span class="n">envWithLambda</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> 
                <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span> <span class="o">(</span><span class="nc">ArgRef</span> <span class="n">index</span><span class="o">)</span> <span class="n">env</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)))</span>

        <span class="n">body</span> <span class="o">|&gt;</span> <span class="n">compile</span> <span class="n">lambdaGenerator</span> <span class="n">defineMethod</span> <span class="n">envWithLambdaArgs</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
        <span class="n">lambdaGenerator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ret</span><span class="o">)</span>
        <span class="n">envWithLambda</span>

    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">local</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="nc">DeclareLocal</span><span class="o">(</span><span class="n">typeOf</span> <span class="n">env</span> <span class="n">value</span><span class="o">)</span>
        <span class="k">let</span> <span class="n">envWithVariable</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">add</span> <span class="n">name</span> <span class="o">(</span><span class="nc">VariableRef</span> <span class="n">local</span><span class="o">)</span> <span class="n">env</span>
        <span class="n">compile'</span> <span class="n">envWithVariable</span> <span class="n">value</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
        <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Stloc</span><span class="o">,</span> <span class="n">local</span><span class="o">)</span>
        <span class="n">envWithVariable</span>
</pre></div>



<p id="p27"><strong class="alt">VariableDef:</strong> We use <code>VariableDef</code> nodes to declare both functions and variables. There are in fact three possibilities here:</p>
<ol>
  <li><code>(define func (arg1 arg2) body)</code></li>

  <li><code>(define func (lambda (arg1 arg2) body))</code></li>

  <li><code>(define variable value)</code></li>
</ol>
<p id="p28">The first two cases are treated the same (in fact, the first case is transformed to the second by <code>insertPrimitives</code>, which we saw in the last post), and both of them define a new named function:</p>
<ol>
  <li>We call <code>defineMethod</code> to obtain a <code>MethodInfo</code> and an <code>ILGenerator</code> for a new method</li>

  <li>So that the function can call itself recursively, we insert the function into the environment before we start generating the function's IL. This changed environment is the one that feeds into the next line of code in the function where the declaration appears.</li>

  <li>We set up a new environment based on the declaring function. This new environment gains a set of <code>ArgRef</code> values that represent the function's arguments.</li>

  <li>We call <code>compile</code> recursively, with the new <code>ILGenerator</code> that <code>defineMethod</code> gave us</li>
</ol>
<div class="notice">
  <h2 class="alt">Detour: Why do we keep a list of parameters if we've got a MethodInfo?</h2>

  <p id="p29">I had originally wanted to represent both our own functions and .NET methods with a .NET <code>MethodInfo</code> object: we need to know the types of the function's parameters in order to call it, and I assumed we could call <code>MethodInfo.GetParameters</code> to obtain them. Unfortunately we're only allowed to call GetParameters on real methods, not <code>DynamicMethod</code> or <code>MethodBuilder</code>, so I had to track the parameter types explicitly.</p>
</div>
<p id="p30">To declare a variable, we first use <code>ILGenerator.DeclareLocal</code> to allocate a new IL local variable, then use the <em>stloc</em> opcode to assign a value to it. As with function declarations, we change the function's environment, and return the changed environment so that it can be fed into the next line of code.</p>

<div class="pygments_murphy"><pre><span class="o">|</span> <span class="nc">VariableRef</span> <span class="n">local</span> <span class="o">-&gt;</span> 
    <span class="n">generator</span><span class="o">.</span><span class="nc">Emit</span><span class="o">(</span><span class="nn">OpCodes</span><span class="p">.</span><span class="nc">Ldloc</span><span class="o">,</span> <span class="n">local</span><span class="o">)</span>
    <span class="n">env</span>
</pre></div>



<p id="p31"><strong class="alt">VariableRef:</strong> Last in our alphabetical list of expression tree nodes is <code>VariableRef</code>, which is the node we inserted into the environment just a moment ago to represent local variables. IL gives us the <em>ldloc</em> opcode, which fetches the value from a local variable and places it into the VM stack.</p>

<div class="pygments_murphy"><pre><span class="n">compile'</span>
</pre></div>



<p id="p32">In the last line of code, we're outside of the <code>compile'</code> definition and back in <code>compile</code>. Recall that we declared <code>compile</code> as a function that accepts two arguments and returns a function that accepts two more: here we're returning that function.</p>
<p id="p33">To finish up, let's compile the Lisp code I wrote in the last post, which generates most of the features in our code generator:</p>

<div class="pygments_murphy"><pre>(define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))
(Console.WriteLine "6! = {0}" (fact 6))
(Console.WriteLine "What is your name?")
(Console.WriteLine "Hello, {0}" (Console.ReadLine))
</pre></div>



<p class="alt" id="p34">IL disassembly</p>

<div class="pygments_murphy"><pre>.class public auto ansi sealed Program
       extends [mscorlib]System.Object
{
  .method public static void  Main() cil managed
  {
    // (Console.WriteLine "6! = {0}" (fact 6))
    IL_0000:  ldstr      "6! = {0}"
    IL_0005:  ldc.i4     0x6
    IL_000a:  call       int32 Program::fact(int32)
    IL_000f:  box        [mscorlib]System.Int32
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string, object)

    // (Console.WriteLine "What is your name?")
    IL_0019:  ldstr      "What is your name\?"
    IL_001e:  call       void [mscorlib]System.Console::WriteLine(object)

    // (Console.WriteLine "Hello, {0}" (Console.ReadLine))
    IL_0023:  ldstr      "Hello, {0}"
    IL_0028:  call       string [mscorlib]System.Console::ReadLine()
    IL_002d:  call       void [mscorlib]System.Console::WriteLine(string, object)
    IL_0032:  ret
  }

  .method private static int32  fact(int32 A_0) cil managed
  {
    // (if (= n 0) ...
    IL_0000:  ldarg      A_0
    IL_0004:  nop
    IL_0005:  nop
    IL_0006:  ldc.i4     0x0
    IL_000b:  beq        IL_002d

    // else: (* n (fact (- n 1)))
    IL_0010:  ldarg      A_0
    IL_0014:  nop
    IL_0015:  nop
    IL_0016:  ldarg      A_0
    IL_001a:  nop
    IL_001b:  nop
    IL_001c:  ldc.i4     0x1
    IL_0021:  sub
    IL_0022:  call       int32 Program::fact(int32)
    IL_0027:  mul
    IL_0028:  br         IL_0032

    // then: 1
    IL_002d:  ldc.i4     0x1
    IL_0032:  ret
  }
}
</pre></div>



<p id="p35">And just for fun, using Reflector to disassemble into C#:</p>
<p class="alt" id="p36">C# decompilation</p>

<div class="pygments_murphy"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">num1</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="p">(</span><span class="n">num1</span> <span class="p">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">num1</span> <span class="p">-</span> <span class="m">1</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"6! = {0}"</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="m">6</span><span class="p">));</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"What is your name?"</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Hello, {0}"</span><span class="p">,</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>






  </span>
</div>



  <div class="after_post"><a href="http://www.partario.com/blog/2009/06/lisp-compiler-in-f-il-generation.html#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  



<div class="blog_post" id="moving-a-perforce-project-to-github">
  <a class="blog_post_title" name="Moving a Perforce project to GitHub" />
  <h2 class="blog_post_title"><a href="/blog/2009/06/moving-a-perforce-project-to-github.html" rel="bookmark" title="Permanent Link to Moving a Perforce project to GitHub">Moving a Perforce project to GitHub</a></h2>
  <small>June 02, 2009 at 08:41 PM | categories: 

<a href='/blog/category/uncategorized'>Uncategorized</a>
 | <a href="http://www.partario.com/blog/2009/06/moving-a-perforce-project-to-github.html#disqus_thread">View Comments</a>
  </small>
  <span class="post_prose">
    
  
<p id="p1">I keep all of my home projects in a local <a href="http://www.perforce.com/">Perforce</a> instance. I wanted to put my Lisp compiler code onto <a href="http://github.com/">GitHub</a>; since I'm not paying for a Perforce licence, I'm limited to a single user.</p>
<p id="p2">The GitHub user account and repository setup process was pretty straightforward, until it came to adding files. I haven't been able to find a single set of instructions for this, but I pieced it together thanks to <a href="http://stackoverflow.com/questions/786909/getting-the-whole-files-history-with-p4-git">Stack Overflow</a>:</p>
<ol>
  <li>You will need the <em>git-p4</em> Python script from here: <a href="http://repo.or.cz/w/git.git?a=tree;f=contrib/fast-import;hb=HEAD">http://repo.or.cz/w/git.git?a=tree;f=contrib/fast-import;hb=HEAD</a></li>

  <li>From the some empty directory -- not the one that contains the Perforce project -- run the following command to import the entire Perforce version history:<br/>
  <code>python git-p4 clone --destination=. //depot/path/to/project/...@all</code></li>

  <li>You now have a brand new local git repository that contains a clone of the project from Perforce. You need to push it to GitHub:<br/>
  <code>git remote add origin git@github.com:username/repository.git<br/>
  git push origin master</code></li>

  <li>To push subsequent Perforce changes to GitHub:<br/>
  <code>git-p4 sync<br/>
  git push origin master</code></li>
</ol>
<p id="p3"><strong class="alt">Edit:</strong> I almost forgot to include <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">the URL of the compiler source</a></p>
<p id="p4"><strong class="alt">Edit 2:</strong> Turns out you mustn't run git commands from a Perforce local directory: as always, Perforce doesn't like it if something else (in this case git) interferes with its local files.</p>



  </span>
</div>



  <div class="after_post"><a href="http://www.partario.com/blog/2009/06/moving-a-perforce-project-to-github.html#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../2">Next Page </a>

        </div><!-- End Prose Block -->
        
  <div class="right_sidebar">
    <div id="right_sidebar">
  <div id="links">
  <h3>About Tim</h3>
  <ul>
      <li><img src="/site_img/icon-github.png" width="16" height="16" alt="Github" valign="middle"/> Github - <a href="https://github.com/timrobinson/">timrobinson</a></li> 
      <li><img src="/site_img/icon-twitter.png" width="16" height="16" alt="Twitter" valign="middle"/> Twitter - <a href="http://twitter.com/1tgr">@1tgr</a></li> 
  </ul>
  </div>
  <div id="blog_post_list">
  <h3>Latest blog posts</h3>
  <ul>
    <li><a href="_posts/030.new_npackage_binaries.markdown">New NPackage binaries</a></li>
    <li><a href="_posts/029.this_week_on_npackage.markdown">This week on NPackage</a></li>
    <li><a href="_posts/028.first.markdown">First six NPackage packages</a></li>
    <li><a href="_posts/027.npackage_news.markdown">NPackage news</a></li>
    <li><a href="_posts/026.net_package_manager_feedback.markdown">.NET package manager feedback</a></li>
  </ul>
  </div>
  <div id="categories">
    <h3>Categories</h3>
    <ul>
     <li><a href="/blog/category/uncategorized">Uncategorized</a> (<a href="/blog/category/uncategorized/feed">rss</a>) (17)</li>
     <li><a href="/blog/category/npackage">NPackage</a> (<a href="/blog/category/npackage/feed">rss</a>) (6)</li>
     <li><a href="/blog/category/compiler">Compiler</a> (<a href="/blog/category/compiler/feed">rss</a>) (7)</li>
    </ul>
  </div> 
  <div id="archives">			
    <h3>Archives</h3>
    <ul>
      <li><a href="/blog/archive/2010/05/1" title="May 2010">May 2010</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2010/04/1" title="April 2010">April 2010</a>&nbsp;(5)</li>
      <li><a href="/blog/archive/2010/03/1" title="March 2010">March 2010</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/11/1" title="November 2009">November 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/10/1" title="October 2009">October 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/08/1" title="August 2009">August 2009</a>&nbsp;(1)</li>
      <li><a href="/blog/archive/2009/07/1" title="July 2009">July 2009</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2009/06/1" title="June 2009">June 2009</a>&nbsp;(6)</li>
      <li><a href="/blog/archive/2009/05/1" title="May 2009">May 2009</a>&nbsp;(3)</li>
      <li><a href="/blog/archive/2009/04/1" title="April 2009">April 2009</a>&nbsp;(6)</li>
    </ul>
  </div>

</div>

  </div>

      </div><!-- End Main Block -->
      <div id="footer">
        
  <p id="credits">
Powered by <a href="http://www.blogofile.com">Blogofile</a>.<br/>
<br/>
RSS feeds for <a href="http://feeds2.feedburner.com/TimRobinson">Entries</a>
 and <a
href="http://timrobinson.disqus.com/latest.rss">Comments</a>.
<br>
</p>
<script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/timrobinson/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>


      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





