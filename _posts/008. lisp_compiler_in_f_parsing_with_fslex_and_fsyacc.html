---
title: "Lisp compiler in F#: Parsing with fslex and fsyacc"
date: "2009/05/31 17:12:56"
updated: "2009/05/31 17:12:56"
categories: Compiler
tags: F#,Lisp
permalink: /blog/2009/05/lisp-compiler-in-f-parsing-with-fslex-and-fsyacc.html
---
<p>This is part 2 of a series of posts on my Lisp compiler written in F#. Previous entry: <a href="/blog/2009/05/lisp-compiler-in-f-introduction.html">Introduction</a> | <a href="http://github.com/timrobinson/fsharp-lisp/tree/master">Browse the full source of the compiler on GitHub</a></p>
<p>In this post I'll talk about the <em>fslex</em> and <em>fsyacc</em> tools, which, as their names suggest, are similar to the widely used <a href="http://en.wikipedia.org/wiki/Lex_programming_tool"><em>lex</em></a> and <a href="http://en.wikipedia.org/wiki/Yacc"><em>yacc</em></a> tools, which generate lexical scanners and parsers respectively.</p>
<p>These tools generate two F# modules that work together:</p>
<ul>
  <li><em>fslex</em> generates code that splits a string into tokens, according to a set of rules similar to regular expressions</li>

  <li><em>fsyacc</em> generates code that recognises sequences of tokens, and does something with them, such as building an expression tree</li>
</ul>
<p><em>fslex</em> and <em>fsyacc</em> are both standalone executables that are installed in the bin subdirectory of an F# distribution. Although can invoke them by hand, their command line parameters and error handling are fairly basic. Luckily F# also ships with a pair of MSBuild tasks that you can put in your .fsproj file.</p>
<ol>
  <li>Open your .fsproj file in a text editor (or, in Visual Studio, unload the project, then click 'Edit ProjectName.fsproj' on the unloaded project's right click menu)</li>

  <li>
    <p>Towards the bottom you should see a line as follows:</p>

    <p><code>&lt;Import Project="$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets" /&gt;</code></p>

    <p>Under this line, paste the following:</p>

    <p><code>&lt;Import Project="$(MSBuildExtensionsPath)\FSharp\1.0\FSharp.PowerPack.Targets" /&gt;</code></p>
  </li>

  <li>If you have the F# May 2009 CTP (version 1.6.9.16) or newer, <strong>remove the Microsoft.FSharp.Targets line</strong>. If you have the September 2008 CTP (version 1.6.9.2) or older, <strong>leave the Microsoft.FSharp.Targets line alone</strong>. (The May version of FSharp.PowerPack.Targets has its own import of Microsoft.FSharp.Targets, so leaving the import in the .fsproj file causes an MSBuild error.)</li>

  <li>
    <p>Slightly higher up in the .fsproj file, you'll see an <code>&lt;ItemGroup&gt;</code> element that contains your source files. Add the following lines; put them at the top of the list so that <em>fslex</em> and <em>fsyacc</em> get run before any of the compilation steps:</p>

    <p><code>&lt;FsYacc Include="YourParser.fsy" /&gt;</code><br />
    <code>&lt;FsLex Include="YourScanner.fsl" /&gt;</code></p>
  </li>

  <li>Save and close the .fsproj file in the text editor, then reload it in Visual Studio to ensure it still loads OK. (You did keep the original version in source control, right?) The .fsy and .fsl files will be missing at this point, but I'm going to discuss them in a moment.</li>

  <li><strong>Extra step for the May CTP:</strong> The DLL that implements the <code>&lt;FsLex&gt;</code> and <code>&lt;FsYacc&gt;</code> tasks is installed to the wrong directory. You'll need to <a href="http://cs.hubfs.net/forums/thread/10484.aspx">follow this set of instructions and copy the FSharp.PowerPack.Build.Tasks.dll file to the right place</a>.</li>
</ol>
<p>Once you've successfully run <em>fslex</em> and <em>fsyacc</em> and generated F# source for the first time, you'll need to include these F# source files in your project. Because the file generated by <em>fslex</em> relies on <em>fsyacc</em>'s token definitions, you'll need to include the generated <em>fsyacc</em> file first -- remember that build order is significant in F#, unlike in C#. Feel free to check this generated source into source control, but remember to check it out before making changes to the .fsl and .fsy sources; these tools thrown an access denied exception if the generated source file is read only.</p>
<p>The .fsy and .fsl files should look familiar if you've used <em>lex</em> and <em>yacc</em> before. Here are the rules I'm using to parse Lisp s-expressions:</p>
<p class="alt"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/FSYacc.fsy">FSYacc.fsy</a> -- generates FSYacc.fsi and FSYacc.fs</p>
<pre class="brush: plain">
%{
open Tim.Lisp.Core
%}

%start parse
%token &lt;string&gt; Identifier
%token &lt;string&gt; Text
%token &lt;int&gt; Digits
%token Apostrophe LeftParen RightParen Eof
%type &lt;Tim.Lisp.Core.LispVal list&gt; parse

%%

Expr: Identifier { Atom $1 }
    | Text { String $1 }
    | Digits { Number $1 }
    | LeftParen ExprList RightParen { $2 |&gt; List.rev |&gt; List }
    | Apostrophe Expr { List [ Atom "quote"; $2 ] }

ExprList: Expr { [ $1 ] }
        | ExprList Expr { $2 :: $1  }

parse: ExprList Eof { List.rev $1 }
</pre>
<p>Note that the <em>fsyacc</em> source defines the list of tokens that it expects the <em>fslex</em> source to emit. Because this is F#, the list of <code>%code</code> statements above results in the generation of one of our old friends, the discriminated union:</p>
<p class="alt"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/FSYacc.fsi">FSYacc.fsi</a> -- generated from FSYacc.fsy</p>
<pre class="brush: fsharp">
// Signature file for parser generated by fsyacc
#light
type token = 
  | Apostrophe
  | LeftParen
  | RightParen
  | Eof
  | Digits of (int)
  | Text of (string)
  | Identifier of (string)
// snip rest of generated code
</pre>
<p>The rest of the file consists of <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>-like rules; here I'm recognising the key parts of s-expression syntax and emitting an expression tree in the form of my own <code>LispVal</code> data structure, which is another discriminated union.</p>
<p>The .fsl file takes text, applies regular expressions to it, and returns a stream of tokens:</p>
<p class="alt"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/FSLex.fsl">FSLex.fsl</a> -- generates FSLex.fs</p>
<pre class="brush: plain">
{
open System
open System.Text
open Microsoft.FSharp.Text.Lexing
open FSYacc
}

let digit = ['0'-'9']
let alpha = ['a'-'z' 'A'-'Z']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let identifier = [^'"' '0'-'9' '(' ')' ' ' '\t' '\n' '\r']
 
rule tokenize = parse
| whitespace        { tokenize lexbuf }
| newline           { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine; tokenize lexbuf }
| ['-']?digit+      { Digits &lt;| Int32.Parse(Encoding.UTF8.GetString(lexbuf.Lexeme)) }
| '('               { LeftParen }
| ')'               { RightParen }
| '\''              { Apostrophe }
| '"' [^'"']* '"'   { let s = Encoding.UTF8.GetString(lexbuf.Lexeme) in Text &lt;| s.Substring(1, s.Length - 2) }
| eof               { Eof }
| identifier+       { Identifier &lt;| Encoding.UTF8.GetString(lexbuf.Lexeme) }
</pre>
<p><em>fslex</em> regular expressions aren't entirely standard:</p>
<ul>
  <li>White space is ignored</li>

  <li>Literal characters are enclosed in single quotes</li>

  <li>You're allowed to use <code>let</code> to define aliases (see <code>digit</code>, <code>alpha</code>, <code>whitespace</code>, <code>newline</code> and <code>identifier</code> above)</li>
</ul>
<p>Each <code>rule</code> block defines a function in the generated F# source that accepts an <code>Microsoft.FSharp.Text.Lexing.LexBuffer&lt;byte&gt;</code> and returns the token type defined by the generated <em>fsyacc</em> source. Although <code>LexBuffer</code> is a generic type, <em>fslex</em> prior to May only generates ASCII parsers, hence the calls to <code>Encoding.UTF8.GetString</code> above. The May CTP adds a --unicode command line parameter, which appears to enable the use of <code>LexBuffer&lt;char&gt;</code>, but I haven't found how to enable this option via the MSBuild task.</p>
<p>Given the generated source code, it's relatively straightforward to write a facade around it. Note that you'll need to add a reference to Microsoft.FSharp.PowerPack.dll in order to use the types in the <code>Microsoft.FSharp.Text.Lexing</code> namespace.</p>
<p class="alt"><a href="http://github.com/timrobinson/fsharp-lisp/blob/b13a8c59066040b7c007b0a4bea28a7fc2163fc1/Core/Parser.fs">Parser.fs</a></p>
<pre class="brush: fsharp">
#light
open System.Text
open Microsoft.FSharp.Text.Lexing

module Parser =
    // Accepts a string and either returns a list of LispVal objects or throws an exception
    let parseString (s : string) = FSYacc.parse FSLex.tokenize &lt;| LexBuffer&lt;_&gt;.FromBytes(Encoding.UTF8.GetBytes(s))
</pre>
<p>In the next post, I'll take the <code>LispVal</code> objects returned by the <code>parseString</code> function and use them to generate actual IL.</p>
