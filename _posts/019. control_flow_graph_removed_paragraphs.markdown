---
title: "Control flow graph: Removed paragraphs"
date: "2009/08/03 10:18:30"
updated: "2009/08/03 10:18:30"
permalink: /blog/2009/08/control_flow_graph_removed_paragraphs.html
---
Because `ILBranchOpCode` and `ILBlock` are defined in terms of each other, I had to put them into the same F# source file as follows:

<pre class="brush: fsharp">
type ILBranchOpCode = ...
and ILBlock = { ... }
</pre>

I also wrote a module with a set of functions for working with `ILBlock` instances:

* `emit instructions`: creates an `ILBlock` containing a list of opcodes
* `empty ()`: creates an empty `ILBlock`. Note the `()`, which denote that `empty` is a function that takes no arguments, not a single value. Because `ILBlock` is partly mutable, the normal F# rules of structural equality do not apply: two `ILBlock` instances are considered different even if they contain the same instructions and branch to the same place.
* `goto branch origin`: change the `Branch` field on `origin` so that it branches to the location given by `branch`
* `beq equalBlock notEqualBlock origin`, `br block origin`, `brtrue trueBlock falseBlock origin` and `ret origin`: wrappers around `goto` that use each of the branch opcodes. These functions allow you to write semi-literate code like this:
<pre class="brush: fsharp">
bTail |&gt; beq thenHead elseHead
</pre>

